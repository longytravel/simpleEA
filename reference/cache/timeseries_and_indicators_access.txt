=== Timeseries and Indicators Access (Pages 2006-2107) ===

--- Page 2006 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2006
Access to Timeseries and Indicator Data
These are functions for working with timeseries and indicators. A timeseries differs from the usual
data array by its reverse ordering - elements of timeseries are indexed from the end of an array to its
begin (from the most recent data to the oldest ones). To copy the time-series values and indicator
data, it's recommended to use dynamic arrays only, because copying functions are designed to allocate
the necessary size of arrays that receive values.
There is an important exception to this rule: if timeseries and indicator values need to be copied
often, for example at each call of OnTick() in Expert Advisors or at each call of OnCalculate() in
indicators, in this case one should better use statically distributed arrays, because operations of
memory allocation for dynamic arrays require additional time, and this will have effect during
testing and optimization.
When using functions accessing timeseries and indicator values, indexing direction should be taken
into account. This is described in the Indexing Direction in Arrays, Buffers and Timeseries section.
Access to indicator and timeseries data is implemented irrespective of the fact whether the requested
data are ready (the so called asynchronous access). This is critically important for the calculation of
custom indicator, so if there are no data, functions of Copy...() type immediately return an error.
However, when accessing form Expert Advisors and scripts, several attempts to receive data are made
in a small pause, which is aimed at providing some time necessary to download required timeseries or
to calculate indicator values.
The Organizing Data Access section describes details of receiving, storing and requesting price data in
the MetaTrader 5 client terminal.
It is historically accepted that an access to the price data in an array is performed from the end of the
data. Physically, the new data are always written at the array end, but the index of the array is always


--- Page 2007 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2007
equal to zero. The 0 index in the timeseries array denotes data of the current bar, i.e. the bar that
corresponds to the unfinished time interval in this timeframe.
A timeframe is the time period, during which a single price bar is formed. There are 21 predefined
standard timeframes. 
Function
Action
SeriesInfoInteger
Returns information about the state of historical data
Bars
Returns the number of bars count in the history for a specified symbol and
period
BarsCalculated
Returns the number of calculated data in an indicator buffer or -1 in the
case of error (data hasn't been calculated yet)
IndicatorCreate
Returns the handle to the specified technical indicator created by an array
of MqlParam type parameters
IndicatorParameters
Based on the specified handle, returns the number of input parameters of
the indicator, as well as the values and types of the parameters
IndicatorRelease
Removes an indicator handle and releases the calculation block of the
indicator, if it's not used by anyone else
CopyBuffer
Gets data of a specified buffer from a specified indicator into an array
CopyRates 
Gets history data of the Rates structure for a specified symbol and period
into an array
CopySeries
Gets the synchronized timeseries from the Rates structure for the
specified symbol-period and the specified amount
CopyTime
Gets history data on bar opening time for a specified symbol and period
into an array
CopyOpen
Gets history data on bar opening price for a specified symbol and period
into an array
CopyHigh
Gets history data on maximal bar price for a specified symbol and period
into an array
CopyLow
Gets history data on minimal bar price for a specified symbol and period
into an array
CopyClose
Gets history data on bar closing price for a specified symbol and period
into an array
CopyTickVolume
Gets history data on tick volumes for a specified symbol and period into an
array
CopyRealVolume
Gets history data on trade volumes for a specified symbol and period into
an array
CopySpread
Gets history data on spreads for a specified symbol and period into an
array


--- Page 2008 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2008
Function
Action
CopyTicks
Gets ticks in the MqlTick format into ticks_array
CopyTicksRange
Gets ticks in the MqlTick format within the specified date range to
ticks_array
iBars
Returns the number of bars of a corresponding symbol and period,
available in history
iBarShift
Returns the index of the bar corresponding to the specified time
iClose
Returns the Close price of the bar (indicated by the 'shift' parameter) on
the corresponding chart
iHigh
Returns the High price of the bar (indicated by the 'shift' parameter) on the
corresponding chart
iHighest
Returns the index of the highest value found on the corresponding chart
(shift relative to the current bar)
iLow
Returns the Low price of the bar (indicated by the 'shift' parameter) on the
corresponding chart
iLowest
Returns the index of the smallest value found on the corresponding chart
(shift relative to the current bar)
iOpen
Returns the Open price of the bar (indicated by the 'shift' parameter) on
the corresponding chart
iTime
Returns the opening time of the bar (indicated by the 'shift' parameter) on
the corresponding chart
iTickVolume
Returns the tick volume of the bar (indicated by the 'shift' parameter) on
the corresponding chart
iRealVolume
Returns the real volume of the bar (indicated by the 'shift' parameter) on
the corresponding chart
iVolume
Returns the tick volume of the bar (indicated by the 'shift' parameter) on
the corresponding chart
iSpread
Returns the spread value of the bar (indicated by the 'shift' parameter) on
the corresponding chart
Despite the fact that by using the ArraySetAsSeries() function it is possible to set up in arrays access
to elements like that in timeseries, it should be remembered that the array elements are physically
stored in one and the same order - only indexing direction changes. To demonstrate this fact let's
perform an example:
   datetime TimeAsSeries[];
//--- set access to the array like to a timeseries
   ArraySetAsSeries(TimeAsSeries,true);
   ResetLastError();
   int copied=CopyTime(NULL,0,0,10,TimeAsSeries);
   if(copied<=0)


--- Page 2009 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2009
     {
      Print("The copy operation of the open time values for last 10 bars has failed");
      return;
     }
   Print("TimeCurrent =",TimeCurrent());
   Print("ArraySize(Time) =",ArraySize(TimeAsSeries));
   int size=ArraySize(TimeAsSeries);
   for(int i=0;i<size;i++)
     {
      Print("TimeAsSeries["+i+"] =",TimeAsSeries[i]);
     }
   datetime ArrayNotSeries[];
   ArraySetAsSeries(ArrayNotSeries,false);
   ResetLastError();
   copied=CopyTime(NULL,0,0,10,ArrayNotSeries);
   if(copied<=0)
     {
      Print("The copy operation of the open time values for last 10 bars has failed");
      return;
     }   
   size=ArraySize(ArrayNotSeries);
   for(int i=size-1;i>=0;i--)
     {
      Print("ArrayNotSeries["+i+"] =",ArrayNotSeries[i]);
     }
As a result we will get the output like this:
TimeCurrent = 2009.06.11 14:16:23
ArraySize(Time) = 10
TimeAsSeries[0] = 2009.06.11 14:00:00
TimeAsSeries[1] = 2009.06.11 13:00:00
TimeAsSeries[2] = 2009.06.11 12:00:00
TimeAsSeries[3] = 2009.06.11 11:00:00
TimeAsSeries[4] = 2009.06.11 10:00:00
TimeAsSeries[5] = 2009.06.11 09:00:00
TimeAsSeries[6] = 2009.06.11 08:00:00
TimeAsSeries[7] = 2009.06.11 07:00:00
TimeAsSeries[8] = 2009.06.11 06:00:00
TimeAsSeries[9] = 2009.06.11 05:00:00
ArrayNotSeries[9] = 2009.06.11 14:00:00
ArrayNotSeries[8] = 2009.06.11 13:00:00
ArrayNotSeries[7] = 2009.06.11 12:00:00
ArrayNotSeries[6] = 2009.06.11 11:00:00
ArrayNotSeries[5] = 2009.06.11 10:00:00
ArrayNotSeries[4] = 2009.06.11 09:00:00
ArrayNotSeries[3] = 2009.06.11 08:00:00


--- Page 2010 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2010
ArrayNotSeries[2] = 2009.06.11 07:00:00
ArrayNotSeries[1] = 2009.06.11 06:00:00
ArrayNotSeries[0] = 2009.06.11 05:00:00
As we see from the output, as the index of TimeAsSeries array increases, the time value of the index
decreases, i.e. we move from the present to the past. For the common array ArrayNotSeries the result
is different - as index grows, we move from past to present.
See Also
ArrayIsDynamic, ArrayGetAsSeries, ArraySetAsSeries, ArrayIsSeries


--- Page 2011 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2011
Indexing Direction in Arrays, Buffers and Timeseries
The default indexing of all arrays and indicator buffers is left to right. The index of the first element
is always equal to zero. Thus, the very first element of an array or indicator buffer with index 0 is by
default on the extreme left position, while the last element is on the extreme right position.
An indicator buffer is a dynamic array of type double, whose size is managed by the client terminals,
so that it always corresponds to the number of bars the indicator is calculated on. A usual dynamic
array of type double is assigned as an indicator buffer using the SetIndexBuffer() function. Indicator
buffers do not require setting of their size using function ArrayResize() - this will be done by the
executing system of the terminal.
Timeseries are arrays with reverse indexing, i.e. the first element of a timeseries is in the extreme
right position, and the last element is in the extreme left position. Timeseries being used for storing
history price data and contain the time information, we can say that the newest data are placed in the
extreme right position of the timeseries, while the oldest data are in the extreme left position. 
So the timeseries element with index 0 contains the information about the latest quote of a symbol. If
a timeseries contains data on a daily timeframe, data of the current yet uncompleted day are located
on the zero position, and the position with index 1 contains yesterday data.
Changing the Indexing Direction
Function ArraySetAsSeries() allows changing the method of accessing elements of a dynamic array; the
physical order of data storing in the computer memory is not changed at that. This function simply
changes the method of addressing array elements, so when copying one array to another using
function ArrayCopy(), the contents of the recipient array will not depend on the indexing direction in
the source array.
Direction of indexing cannot be changed for statically distributed arrays. Even if an array was passed
as a parameter to a function, attempts to change the indexing direction inside this function will bring
no effect.
For indicator buffers, like for usual arrays, indexing direction can also be set as backward (like in
timeseries), i.e. reference to the zero position in the indicator buffer will mean reference to the last
value on the corresponding indicator buffer and this will correspond to the value of the indicator on the
latest bar. Still, the physical location of indicator bars will be unchanged.
Receiving Price Data in Indicators
Each custom indicator must necessarily contain the OnCalculate() function, to which price data
required for calculating values in indicator buffers are passed. Indexing direction in these passed
arrays can be found out using function ArrayGetAsSeries().
Arrays passed to the function reflect price data, i.e. these arrays have the sign of a timeseries and
function ArrayIsSeries() will return true when checking these arrays. However, in any case indexing
direction should be checked only by function ArrayGetAsSeries(). 
In order not to be dependent on default values, ArraySetAsSeries() should be unconditionally called for
the arrays you are going to work with, and set the required direction.
Receiving Price Data and Indicator Values


--- Page 2012 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2012
Default indexing direction of all arrays in Expert Advisors, indicators and scripts is left-to-right. If
necessary, in any mql5 program you can request timeseries values on any symbol and timeframe, as
well as values of indicators calculated on any symbol and timeframe.
Use functions Copy...() for these purposes:
· CopyBuffer – copy values of an indicator buffer to an array of double type;
· CopyRates – copy price history to an array of structures MqlRates;
· CopyTime – copy Time values to an array of datetime type;
· CopyOpen – copy Open values to an array of double type;
· CopyHigh – copy High values to an array of double type;
· CopyLow – copy Low values to an array of double type;
· CopyClose – copy Close values to an array of double type;
· CopyTickVolume – copy tick volumes to an array of long type;
· CopyRealVolume – copy equity volumes to a long type array;
· CopySpread – copy the spread history to an array of int type;
All these functions work in a similar way. Let's consider the data obtaining mechanism on the example
of CopyBuffer(). It is implied that the indexing direction of requested data is that of timeseries, and
the position with index 0 (zero) stores data of the current yet uncompleted bar. In order to get access
to  these data we need to copy the necessary volume of data into the recipient array, e.g. into array
buffer. 
When copying we need to specify the starting position in the source array, starting from which data
will be copied to the recipient array. In case of success, the specified number of elements will be
copied to the recipient array from the source array (from the indicator buffer in this case).
Irrespective of the indexing value set in the recipient array, copying is always performed as is shown
in the above figure.
If it is expected that price data will be handled in a loop with a large number of iterations, it is
advisable that you check the fact of forced program termination using the IsStopped() function:
int copied=CopyBuffer(ma_handle,// Indicator handle
                      0,        // The index of the indicator buffer
                      0,        // Start position for copying
                      number,   // Number of values to copy 
                      Buffer    // The array that receives the values


--- Page 2013 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2013
                      );
if(copied<0) return;
int k=0;
while(k<copied && !IsStopped())
  {
   //--- Get the value for the k index
   double value=Buffer[k];
   // ... 
   // work with value
   k++;
  }
Example:
input int per=10; // period of the exponent
int ma_handle;    // indicator handle
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   ma_handle=iMA(_Symbol,0,per,0,MODE_EMA,PRICE_CLOSE);
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
   double ema[10];
   int copied=CopyBuffer(ma_handle,// indicator handle
                         0,        // index of the indicator buffer
                         0,        // starting position to copy from
                         10,       // number of values for copying
                         ema       // value receiving array
                         );
   if(copied<0) return;
// .... further code
  }
See also
Organizing Data Access


--- Page 2014 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2014
Organizing Data Access
In this section questions connected with obtaining, storing and requesting price data (timeseries) are
considered.
Receiving Data from a Trade Server
Before price data become available in the MetaTrader 5 terminal, they must be received and
processed. To receive data, connection to the MetaTrader 5 trade server must be established. Data
are received in the form of packed blocks of minute bars from the server upon the request of a
terminal.
The mechanism of server reference for data doesn't depend on how the request has been initiated - by
a user when navigating in a chart or in a program way in the MQL5 language.
Storing Intermediate Data
Data received from a server are automatically unpacked and saved in the HCC intermediate format.
Data 
on 
each 
symbol 
are 
written 
into 
a 
separate 
folder:
terminal_directory\bases\server_name\history\symbol_name. For example, data on EURUSD received
from the MetaQuotes-Demo server will be stored in terminal_directory\bases\MetaQuotes-
Demo\history\EURUSD\.
Data are written into files with .hcc extension. Each file stores data of minute bars for one year. For
example, the file named 2009.hcc in the EURUSD folder contains minute bars of EURUSD for year 2009.
These files are used for preparing price data for all timeframes and are not intended for direct access.
Obtaining Data on a Necessary Timeframe out of Intermediate Data
Intermediate HCC files are used as the data source for building price data for requested timeframes in
the HC format. Data of HC format are timeseries that are maximally prepared for a quick access. They
are created upon a request of a chart or a MQL5 program. The volume of data should not exceed the
value of the "Max bars in charts" parameter. Data are stored for further using in files with hc
extension.
To save resources, data on a timeframe are stored and saved in RAM only if necessary. If not called
for a long time, they are released from RAM and saved into a file. For each timeframe, data are
prepared regardless of whether there are ready data for other timeframes or not. Rules of forming and
accessing data are the same for all timeframes. I.e., despite the fact that the unit data stored in HCC
is one minute (M1), the availability of HCC data doesn't mean the availability of data on M1 timeframe
as HC in the same volume.
Receipt of new data from a server calls automatic update of used price data in HC format of all
timeframes. It also leads to the recalculation of all indicators that implicitly use them as input data for
calculations.
Parameter "Max bars in chart"
The "Max bars in charts" parameter restricts number of bars in HC format available to charts,
indicators and mql5 programs. This is valid for all available timeframes and serves, first of all, to save
computer resources.


--- Page 2015 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2015
When setting a large value of this parameter, it should be remembered, that if deep history price data
for small timeframes are available, memory used for storing timeseries and indicator buffers can
become hundreds of megabytes and reach the RAM restriction for the client terminal program (2Gb for
32-bit applications of MS Windows).
Change of the "Max bars in charts" comes into effect after the client terminal is restarted. Change of
this parameter causes neither automatic referring to a server for additional data, nor forming of
additional bars of timeseries. Additional price data are requested from the server, and timeseries are
updated taking into account the new limitation, in case of either chart scroll to the area with no data,
or when data are requested by a mql5 program.
Volume of data requested from the server corresponds to the required number of bars of this
timeframe with the "Max bars in charts" parameter taken into account. The restriction set by this
parameter is not strict, and in some cases the number of available bars for a timeframe can be a little
more than the current parameter value.
Data Availability
Presence of data on HCC format or even in the prepared for using HC format does not always denote
the absolute availability of these data to be shown in a chart or to be used in MQL5 programs.
When accessing to price data or indicator values from a mql5 program it should be remembered that
their availability in a certain moment of time or starting from a certain moment of time is not
guaranteed. It is connected with the fact that with the purpose of saving resources, the full copy of
data necessary for a mql5 program isn't stored in MetaTrader 5; only direct access to the terminal
database is given.
The price history for all timeframes is built from common data of HCC format, and any update of data
from a server leads to the update of data for all timeframes and to the recalculation of indicators. Due
to this access to data can be closed, even if these data were available a moment ago.
Synchronization of the Terminal Data and Server Data
Since a mql5 program can call data from any symbol and timeframe, there is a possibility that data of
a necessary timeseries are not formed yet in the terminal or the necessary price data aren't
synchronized with the trade server. In this case it's hard to predict the latency time.
Algorithms using "do-nothing" loops are not the best solution. The only exception in this case are
scripts, because they do not have any alternative algorithm choice due to not having event handling.
For custom indicators such algorithms, as well as any other "do-nothing" loops are strongly not
recommended, because they lead to termination of calculation of all indicators and any other handling
of price data of the symbol.
For Expert Advisors and indicators, it is better to use the event model of handling. If during handling
of OnTick() or OnCalculate() event, data receipt for the required timeseries failed, you should exit the
event handler, relying on the access availability during the next call of the handler.
Example of a Script for Adding History
Let's consider the example of a script that executes a request to receive history for the selected
symbol from a trade server. The script is intended for running in a chart of a selected symbol;


--- Page 2016 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2016
timeframe doesn't matter, because, as it was mentioned above, price data are received from a trade
server as packed one minute data, from which any predefined timeseries is constructed then.
Write all actions concerning data receipt as a separate function CheckLoadHistory(symbol, timeframe,
start_date):
int CheckLoadHistory(string symbol,ENUM_TIMEFRAMES period,datetime start_date)
  {
  }
The CheckLoadHistory() function is designed as a universal function that can be called from any
program (Expert Advisor, script or indicator); and therefore it requires three input parameters: symbol
name, period and start date to indicate the beginning of price history you need. 
Insert necessary checks into the function code before requesting the missing history. First of all, we
should make sure that the symbol name and period value are correct:
   if(symbol==NULL || symbol=="") symbol=Symbol();
   if(period==PERIOD_CURRENT)     period=Period();
Then let's make sure that the symbol is available in the MarketWatch window, i.e., the history for the
symbol will be available when sending a request to a trade server. If there is no such a symbol in
MarketWatch, add it using the SymbolSelect() function.
   if(!SymbolInfoInteger(symbol,SYMBOL_SELECT))
     {f
      if(GetLastError()==ERR_MARKET_UNKNOWN_SYMBOL) return(-1);
      SymbolSelect(symbol,true);
     }
Now we should receive the start date of the available history for the indicated symbol/period pair.
Perhaps, the value of the input parameter startdate, passed to CheckLoadHistory(), is within the
available history; then request to a trade server is not needed. In order to obtain the very first date
for the symbol-period as of the moment, the SeriesInfoInteger() function with the SERIES_FIRSTDATE
modifier is used.
   SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date);
   if(first_date>0 && first_date<=start_date) return(1);
The next important check is checking the type of the program, from which the function is called. Note
that it is not desirable to send a request to update the timeseries from indicator with the same
period. The undesirability of requesting data on the same symbol-period as that of the indicator is
conditioned by the fact that update of history data is performed in the same thread where the
indicator operates. So the possibility of deadlock occurrence is high. To check this use the
MQL5InfoInteger() function with the MQL5_PROGRAM_TYPE modifier.
   if(MQL5InfoInteger(MQL5_PROGRAM_TYPE)==PROGRAM_INDICATOR && Period()==period && Sym
      return(-4);
If all the checks have been passed successfully, make the last attempt to do without referring to the
trade server. First let's find out the start date, for which minute data in HCC format are available.
Request this value using the SeriesInfoInteger() function with the SERIES_TERMINAL_FIRSTDATE
modifier and again compare it to the value of the start_date parameter.


--- Page 2017 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2017
   if(SeriesInfoInteger(symbol,PERIOD_M1,SERIES_TERMINAL_FIRSTDATE,first_date))
     {
      //--- there is loaded data to build timeseries
      if(first_date>0)
        {
         //--- force timeseries build
         CopyTime(symbol,period,first_date+PeriodSeconds(period),1,times);
         //--- check date
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            if(first_date>0 && first_date<=start_date) return(2);
        }
     }
If after all the checks the execution thread is still in the body of the CheckLoadHistory() function, it
means there is a necessity to request the missing price data from a trade server. First, return the
value of "Max bars in chart" using the TerminalInfoInteger() function:
  int max_bars=TerminalInfoInteger(TERMINAL_MAXBARS);
We'll need it to prevent requesting extra data. Then find the very first date in the symbol history on
the trade server (regardless of the period) using already known function SeriesInfoInteger() with the
SERIES_SERVER_FIRSTDATE modifier.
   datetime first_server_date=0;
   while(!SeriesInfoInteger(symbol,PERIOD_M1,SERIES_SERVER_FIRSTDATE,first_server_date
      Sleep(5);
Since the request is an asynchronous operation, the function is called in the loop with a small delay of
5 milliseconds until the first_server_date variable receives a value, or the loop execution is
terminated by a user (IsStopped() will return true in this case). Let's indicate a correct value of the
start date, starting from which we request price data from a trade server.
   if(first_server_date>start_date) start_date=first_server_date;
   if(first_date>0 && first_date<first_server_date)
      Print("Warning: first server date ",first_server_date," for ",
symbol," does not match to first series date ",first_date);
If the start date first_server_date of the server is lower than the start date first_date of the symbol in
HCC format, the corresponding entry will be output in the journal.
Now we are ready to make a request to a trade server asking for missing price data. Make the request
in the form of a loop and start filling out its body:
   while(!IsStopped())
     {
      //1. wait for synchronization between the re-built timeseries and intermediate h
      //2. receive the current number of bars in this timeseries
      //    if bars is larger than Max_bars_in_chart, we can exit, work is over
      //3. obtain the start date first_date in the re-built timeseries and compare it 
      //    if first_date is lower than start_date, we can exit, work is over
      //4. request from a server a new part of history - 100 bars starting from last a
     }


--- Page 2018 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2018
The first three points are implemented by already known means.
   while(!IsStopped())
     {
      //--- 1.wait till timeseries re-build process is over
      while(!SeriesInfoInteger(symbol,period,SERIES_SYNCHRONIZED) && !IsStopped())
         Sleep(5);
      //--- 2.request how many bars we have
      int bars=Bars(symbol,period);
      if(bars>0)
        {
         //--- bars more than ones that can be drawn in the chart, exit
         if(bars>=max_bars) return(-2); 
         //--- 3. return the current start date in the timeseries
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            // start date was earlier than that requested, task completed
            if(first_date>0 && first_date<=start_date) return(0);
        }
      //4. Request from a server a new part of history - 100 bars starting from last a
     }
The last fourth point is left - requesting history. We can't refer to a server directly, but any Copy-
function automatically initiates request sending to a server, if the history in HCC format is not
enough. Since the time of the very first start date in the first_date variable is the simple and natural
criterion to evaluate the request execution degree, then the easiest way is to use the CopyTime()
function.
When calling functions that copy any data from timeseries, it should be noted that the start parameter
(number of the bar, starting from which price data should be copied) must always be within the
available terminal history. If you have only 100 bars, it meaningless to try copying 300 bars starting
from the bar with the index 500. Such a request will be understood as an erroneous and won't be
handled, i.e. no additional history will be loaded from a trade server.
That's why we'll copy bars in groups of 100 starting from the bar with the bars index. This will provide
the smooth loading of missing history from a trade server. Actually a little more than the requested
100 bars will be loaded, while server sends oversized history.
   int copied=CopyTime(symbol,period,bars,100,times);
 After the copying operation, we should analyze the number of copied elements. If the attempt fails,
then value of the copied will be equal to null and the value of the fail_cnt counter will be increased by
1. After 100 failing attempts, the operation of the function will be stopped.
int fail_cnt=0;
...
   int copied=CopyTime(symbol,period,bars,100,times);
   if(copied>0)
     {
      //--- check data
      if(times[0]<=start_date)  return(0);  // the copied value is smaller, ready
      if(bars+copied>=max_bars) return(-2); // bars are more than can be drawn in the 


--- Page 2019 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2019
      fail_cnt=0;
     }
   else
     {
      //--- no more than 100 failing attempts in succession
      fail_cnt++;
      if(fail_cnt>=100) return(-5);
      Sleep(10);
     }
So, not only correct handling of the current situation at each moment of execution is implemented in
the function, but also the termination code is returned, that can be handled after calling the
CheckLoadHistory() function for getting additional information. For example, this way:
   int res=CheckLoadHistory(InpLoadedSymbol,InpLoadedPeriod,InpStartDate);
   switch(res)
     {
      case -1 : Print("Unknown symbol ",InpLoadedSymbol);                     break;
      case -2 : Print("More requested bars than can be drawn in the chart"); break;
      case -3 : Print("Execution stopped by user");                          break;
      case -4 : Print("Indicator mustn't load its own data");                break;
      case -5 : Print("Loading failed");                                     break;
      case  0 : Print("All data loaded");                                    break;
      case  1 : Print("Already available data in timeseries are enough");    break;
      case  2 : Print("Timeseries is built from available terminal data");   break;
      default : Print("Execution result undefined");
     }
The full code of the function can be found in the example of a script that shows the correct
organization of access to any data with the handling of request's results.
Code:
//+------------------------------------------------------------------+
//|                                              TestLoadHistory.mq5 |
//|                        Copyright 2009, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "2009, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.02"
#property script_show_inputs
//--- input parameters
input string          InpLoadedSymbol="NZDUSD";   // Symbol to be load
input ENUM_TIMEFRAMES InpLoadedPeriod=PERIOD_H1;  // Period to be loaded
input datetime        InpStartDate=D'2006.01.01'; // Start date
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()


--- Page 2020 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2020
  {
   Print("Start load",InpLoadedSymbol+","+GetPeriodName(InpLoadedPeriod),"from",InpSta
//---
   int res=CheckLoadHistory(InpLoadedSymbol,InpLoadedPeriod,InpStartDate);
   switch(res)
     {
      case -1 : Print("Unknown symbol ",InpLoadedSymbol);             break;
      case -2 : Print("Requested bars more than max bars in chart"); break;
      case -3 : Print("Program was stopped");                        break;
      case -4 : Print("Indicator shouldn't load its own data");      break;
      case -5 : Print("Load failed");                                break;
      case  0 : Print("Loaded OK");                                  break;
      case  1 : Print("Loaded previously");                          break;
      case  2 : Print("Loaded previously and built");                break;
      default : Print("Unknown result");
     }
//---
   datetime first_date;
   SeriesInfoInteger(InpLoadedSymbol,InpLoadedPeriod,SERIES_FIRSTDATE,first_date);
   int bars=Bars(InpLoadedSymbol,InpLoadedPeriod);
   Print("First date ",first_date," - ",bars," bars");
//---
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CheckLoadHistory(string symbol,ENUM_TIMEFRAMES period,datetime start_date)
  {
   datetime first_date=0;
   datetime times[100];
//--- check symbol & period
   if(symbol==NULL || symbol=="") symbol=Symbol();
   if(period==PERIOD_CURRENT)     period=Period();
//--- check if symbol is selected in the Market Watch
   if(!SymbolInfoInteger(symbol,SYMBOL_SELECT))
     {
      if(GetLastError()==ERR_MARKET_UNKNOWN_SYMBOL) return(-1);
      SymbolSelect(symbol,true);
     }
//--- check if data is present
   SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date);
   if(first_date>0 && first_date<=start_date) return(1);
//--- don't ask for load of its own data if it is an indicator
   if(MQL5InfoInteger(MQL5_PROGRAM_TYPE)==PROGRAM_INDICATOR && Period()==period && Sym
      return(-4);
//--- second attempt
   if(SeriesInfoInteger(symbol,PERIOD_M1,SERIES_TERMINAL_FIRSTDATE,first_date))
     {
      //--- there is loaded data to build timeseries


--- Page 2021 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2021
      if(first_date>0)
        {
         //--- force timeseries build
         CopyTime(symbol,period,first_date+PeriodSeconds(period),1,times);
         //--- check date
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            if(first_date>0 && first_date<=start_date) return(2);
        }
     }
//--- max bars in chart from terminal options
   int max_bars=TerminalInfoInteger(TERMINAL_MAXBARS);
//--- load symbol history info
   datetime first_server_date=0;
   while(!SeriesInfoInteger(symbol,PERIOD_M1,SERIES_SERVER_FIRSTDATE,first_server_date
      Sleep(5);
//--- fix start date for loading
   if(first_server_date>start_date) start_date=first_server_date;
   if(first_date>0 && first_date<first_server_date)
      Print("Warning: first server date ",first_server_date," for ",symbol,
            " does not match to first series date ",first_date);
//--- load data step by step
   int fail_cnt=0;
   while(!IsStopped())
     {
      //--- wait for timeseries build
      while(!SeriesInfoInteger(symbol,period,SERIES_SYNCHRONIZED) && !IsStopped())
         Sleep(5);
      //--- ask for built bars
      int bars=Bars(symbol,period);
      if(bars>0)
        {
         if(bars>=max_bars) return(-2);
         //--- ask for first date
         if(SeriesInfoInteger(symbol,period,SERIES_FIRSTDATE,first_date))
            if(first_date>0 && first_date<=start_date) return(0);
        }
      //--- copying of next part forces data loading
      int copied=CopyTime(symbol,period,bars,100,times);
      if(copied>0)
        {
         //--- check for data
         if(times[0]<=start_date)  return(0);
         if(bars+copied>=max_bars) return(-2);
         fail_cnt=0;
        }
      else
        {
         //--- no more than 100 failed attempts
         fail_cnt++;


--- Page 2022 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2022
         if(fail_cnt>=100) return(-5);
         Sleep(10);
        }
     }
//--- stopped
   return(-3);
  }
//+------------------------------------------------------------------+
//| Returns string value of the period                               |
//+------------------------------------------------------------------+
string GetPeriodName(ENUM_TIMEFRAMES period)
  {
   if(period==PERIOD_CURRENT) period=Period();
//---
   switch(period)
     {
      case PERIOD_M1:  return("M1");
      case PERIOD_M2:  return("M2");
      case PERIOD_M3:  return("M3");
      case PERIOD_M4:  return("M4");
      case PERIOD_M5:  return("M5");
      case PERIOD_M6:  return("M6");
      case PERIOD_M10: return("M10");
      case PERIOD_M12: return("M12");
      case PERIOD_M15: return("M15");
      case PERIOD_M20: return("M20");
      case PERIOD_M30: return("M30");
      case PERIOD_H1:  return("H1");
      case PERIOD_H2:  return("H2");
      case PERIOD_H3:  return("H3");
      case PERIOD_H4:  return("H4");
      case PERIOD_H6:  return("H6");
      case PERIOD_H8:  return("H8");
      case PERIOD_H12: return("H12");
      case PERIOD_D1:  return("Daily");
      case PERIOD_W1:  return("Weekly");
      case PERIOD_MN1: return("Monthly");
     }
//---
   return("unknown period");
  }


--- Page 2023 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2023
SeriesInfoInteger
Returns information about the state of historical data. There are 2 variants of function calls.
Directly returns the property value.
long  SeriesInfoInteger(
   string                     symbol_name,     // symbol name
   ENUM_TIMEFRAMES            timeframe,       // period
   ENUM_SERIES_INFO_INTEGER   prop_id,         // property identifier
   );
Returns true or false depending on the success of the function run.
bool  SeriesInfoInteger(
   string                     symbol_name,     // symbol name
   ENUM_TIMEFRAMES            timeframe,       // period
   ENUM_SERIES_INFO_INTEGER   prop_id,         // property ID
   long&                      long_var         // variable for getting info
   );
Parameters
symbol_name
[in]  Symbol name.
timeframe
[in]  Period.
prop_id
[in]  Identifier of the requested property, value of the ENUM_SERIES_INFO_INTEGER enumeration.
long_var
[out]  Variable to which the value of the requested property is placed.
Return Value
In the first case, it returns value of the long type. 
For the second case,  it returns true, if the specified property is available and its value has been
placed into long_var variable, otherwise it returns false. For more details about an error, call
GetLastError().
Example:
void OnStart()
  {
//---
   Print("Total number of bars for the symbol-period at this moment = ",
         SeriesInfoInteger(Symbol(),Period(),SERIES_BARS_COUNT));
   Print("The first date for the symbol-period at this moment = ",
         (datetime)SeriesInfoInteger(Symbol(),Period(),SERIES_FIRSTDATE));


--- Page 2024 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2024
   Print("The first date in the history for the symbol-period on the server = ",
         (datetime)SeriesInfoInteger(Symbol(),Period(),SERIES_SERVER_FIRSTDATE));
   Print("Symbol data are synchronized = ",
         (bool)SeriesInfoInteger(Symbol(),Period(),SERIES_SYNCHRONIZED));
  }


--- Page 2025 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2025
Bars
Returns the number of bars count in the history for a specified symbol and period. There are 2
variants of functions calls.
Request all of the history bars
int  Bars(
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe        // period
   );
Request the history bars for the selected time interval
int  Bars(
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   datetime         start_time,      // start date and time
   datetime         stop_time        // end date and time
   );
Parameters
symbol_name
[in]  Symbol name.
timeframe
[in]  Period.
start_time
[in]  Bar time corresponding to the first element.
stop_time
[in]  Bar time corresponding to the last element.
Return Value
If the start_time and stop_time parameters are defined, the function returns the number of bars in
the specified time interval, otherwise it returns the total number of bars.
Note
If data for the timeseries with specified parameters are not formed in the terminal by the time of
the Bars() function call, or data of the timeseries are not synchronized with a trade server by the
moment of the function call, the function returns a zero value.
When requesting the number of bars in a specified time interval, only bars with an open time falling
within the interval are considered. For example, if the current day of the week is Saturday and the
request is made for the number of W1 bars with start_time=last_tuesday and stop_time=last_friday,
the function will return 0 since the open time of a W1 timeframe is always Sunday and not a single
W1 bar falls within the specified interval.
Sample request for the number of all history bars:


--- Page 2026 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2026
   int bars=Bars(_Symbol,_Period);
   if(bars>0)
     {
      Print("Number of bars in the terminal history for the symbol-period at the momen
     }
   else  //no available bars
     {
      //--- data on the symbol might be not synchronized with data on the server
      bool synchronized=false;
      //--- loop counter
      int attempts=0;
      // make 5 attempts to wait for synchronization
      while(attempts<5)
        {
         if(SeriesInfoInteger(Symbol(),0,SERIES_SYNCHRONIZED))
           {
            //--- synchronization done, exit
            synchronized=true;
            break;
           }
         //--- increase the counter
         attempts++;
         //--- wait 10 milliseconds till the next iteration
         Sleep(10);
        }
      //--- exit the loop after synchronization
      if(synchronized)
        {
         Print("Number of bars in the terminal history for the symbol-period at the mo
         Print("The first date in the terminal history for the symbol-period at the mo
               (datetime)SeriesInfoInteger(Symbol(),0,SERIES_FIRSTDATE));
         Print("The first date in the history for the symbol on the server = ",
               (datetime)SeriesInfoInteger(Symbol(),0,SERIES_SERVER_FIRSTDATE));
        }
      //--- synchronization of data didn't happen
      else
        {
         Print("Failed to get number of bars for ",_Symbol);
        }
     }
Sample request for the number of bars in the specified interval:
   int n;
   datetime date1 = D'2016.09.02 23:55'; // Friday
   datetime date2 = D'2016.09.05 00:00'; // Monday
   datetime date3 = D'2016.09.08 00:00'; // Thursday
   //---
   n=Bars(_Symbol,PERIOD_H1,D'2016.09.02 02:05',D'2016.09.02 10:55');


--- Page 2027 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2027
   Print("Number of bars: ",n); // Output: "Number of bars: 8", H2 bar is considered i
   n=Bars(_Symbol,PERIOD_D1,date1,date2);
   Print("Number of bars: ",n); // Output: "Number of bars: 1", since an open time of 
   n=Bars(_Symbol,PERIOD_W1,date2,date3);
   Print("Number of bars: ",n); // Output: "Number of bars: 0", since not a single W1 
See also
Event Handling Functions 


--- Page 2028 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2028
BarsCalculated
Returns the number of calculated data for the specified indicator.
int  BarsCalculated(
   int       indicator_handle,     // indicator handle
   );
Parameters
indicator_handle
[in]  The indicator handle, returned by the corresponding indicator function.
Return Value
Returns the amount of calculated data in the indicator buffer or -1 in the case of error (data not
calculated yet)
Note
The function is useful when it's necessary to get the indicator data immediately after its creation
(indicator handle is available).
Example:
void OnStart()
  {
   double Ups[];
//--- set timeseries ordering for the arrays
   ArraySetAsSeries(Ups,true);
//--- create handle for the Fractal Indicator
   int FractalsHandle=iFractals(NULL,0);
//--- reset the error code
   ResetLastError();
//--- try to copy the indicator values
   int i,copied=CopyBuffer(FractalsHandle,0,0,1000,Ups);
   if(copied<=0)
     {
      Sleep(50);
      for(i=0;i<100;i++)
        {
         if(BarsCalculated(FractalsHandle)>0)
            break;
         Sleep(50);
        }
      copied=CopyBuffer(FractalsHandle,0,0,1000,Ups);
      if(copied<=0)
        {
         Print("Failed to copy upper fractals. Error = ",GetLastError(),
         "i = ",i,"    copied = ",copied);
         return;
        }


--- Page 2029 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2029
       else
         Print("Upper fractals copied",
         "i = ",i,"    copied = ",copied);
     }
   else Print("Upper fractals copied. ArraySize = ",ArraySize(Ups));
  }


--- Page 2030 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2030
IndicatorCreate
The function returns the handle of a specified technical indicator created based on the array of
parameters of MqlParam type.
int  IndicatorCreate(
   string           symbol,                            // symbol name
   ENUM_TIMEFRAMES  period,                            // timeframe
   ENUM_INDICATOR   indicator_type,                    // indicator type from the enum
   int              parameters_cnt=0,                  // number of parameters
   const MqlParam&  parameters_array[]=NULL,           // array of parameters
   );
Parameters
symbol
[in] Name of a symbol, on data of which the indicator is calculated. NULL means the current
symbol.
period
[in]  The value of the timeframe can be one of values of the ENUM_TIMEFRAMES enumeration, 0
means the current timeframe.
indicator_type
[in]  Indicator type, can be one of values of the ENUM_INDICATOR enumeration.
parameters_cnt
[in] The number of parameters passed in the parameters_array[] array. The array elements have a
special structure type MqlParam. By default, zero - parameters are not passed. If you specify a
non-zero number of parameters, the parameter parameters_array is obligatory. You can pass no
more than 64 parameters.
parameters_array[]=NULL
[in]  An array of MqlParam type, whose elements contain the type and value of each input
parameter of a technical indicator.
Return Value
Returns the handle of a specified technical indicator,  in case of failure returns INVALID_HANDLE.
Note
If the indicator handle of IND_CUSTOM type is created, the type field of the first element of the
array of input parameters parameters_array must have the TYPE_STRING value of the 
ENUM_DATATYPE enumeration, and the string_value field of the first element must contain the
name of the custom indicator. The custom indicator must be compiled (file with EX5 extension) and
located in the directory MQL5/Indicators of the client terminal or in a subdirectory.
Indicators that require testing are defined automatically from the call of the iCustom() function, if
the corresponding parameter is set through a constant string. For all other cases (use of the
IndicatorCreate() function or use of a non-constant string in the parameter that sets the indicator
name) the property #property tester_indicator is required:
#property tester_indicator "indicator_name.ex5"


--- Page 2031 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2031
If the first form of the call is used in a custom indicator, you can additionally indicate as the last
parameter on what data it will be calculated when passing input parameters. If the "Apply to"
parameter is not specified explicitly, the default calculation is based on the PRICE_CLOSE values.
Example:
void OnStart()
  {
   MqlParam params[];
   int      h_MA,h_MACD;
//--- create iMA("EURUSD",PERIOD_M15,8,0,MODE_EMA,PRICE_CLOSE);
   ArrayResize(params,4);
//--- set ma_period
   params[0].type         =TYPE_INT;
   params[0].integer_value=8;
//--- set ma_shift
   params[1].type         =TYPE_INT;
   params[1].integer_value=0;
//--- set ma_method
   params[2].type         =TYPE_INT;
   params[2].integer_value=MODE_EMA;
//--- set applied_price
   params[3].type         =TYPE_INT;
   params[3].integer_value=PRICE_CLOSE;
//--- create MA
   h_MA=IndicatorCreate("EURUSD",PERIOD_M15,IND_MA,4,params);
//--- create iMACD("EURUSD",PERIOD_M15,12,26,9,h_MA);
   ArrayResize(params,4);
//--- set fast ma_period
   params[0].type         =TYPE_INT;
   params[0].integer_value=12;
//--- set slow ma_period
   params[1].type         =TYPE_INT;
   params[1].integer_value=26;
//--- set smooth period for difference
   params[2].type         =TYPE_INT;
   params[2].integer_value=9;
//--- set indicator handle as applied_price
   params[3].type         =TYPE_INT;
   params[3].integer_value=h_MA;
//--- create MACD based on moving average
   h_MACD=IndicatorCreate("EURUSD",PERIOD_M15,IND_MACD,4,params);
//--- use indicators
//--- . . .
//--- release indicators (first h_MACD)
   IndicatorRelease(h_MACD);
   IndicatorRelease(h_MA);
  }


--- Page 2032 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2032
IndicatorParameters
Based on the specified handle, returns the number of input parameters of the indicator, as well as the
values and types of the parameters.
int  IndicatorParameters(
   int               indicator_handle,     // indicator handle
   ENUM_INDICATOR&   indicator_type,       // a variable for receiving the indicator t
   MqlParam&         parameters[]          // an array for receiving parameters
   );
Parameters
indicator_handle
[in]  The handle of the indicator, for which you need to know the number of parameters its is
calculated on.
indicator_type
[out]  A variable if the ENUM_INDICATOR type, into which the indicator type will be written.
parameters[]
[out]  A dynamic array for receiving values of the MqlParam type, into which the list of indicator
parameters will be written. The array size is returned by the IndicatorParameters() function.
Return Value
The number of input parameters of the indicator with the specified handle. In case of an error
returns -1. For more details about the error call the GetLastError() function.
Example:
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- The number of windows on the chart (at least one main window is always present)
   int windows=(int)ChartGetInteger(0,CHART_WINDOWS_TOTAL);
//--- Go through the chart windows
   for(int w=0;w<windows;w++)
     {
      //--- The number of indicators in this window/subwindow
      int total=ChartIndicatorsTotal(0,w);
      //--- Take all indicators in the window
      for(int i=0;i<total;i++)
        {
         //--- Get the short name of the indicator
         string name=ChartIndicatorName(0,w,i);
         //--- Get the indicator handle
         int handle=ChartIndicatorGet(0,w,name);
         //--- Add to log


--- Page 2033 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2033
         PrintFormat("Window=%d,  indicator #%d,  handle=%d",w,i,handle);
         //---
         MqlParam parameters[];
         ENUM_INDICATOR indicator_type;
         int params=IndicatorParameters(handle,indicator_type,parameters);
         //--- The header of the message
         string par_info="Short name "+name+", type "
                         +EnumToString(ENUM_INDICATOR(indicator_type))+"\r\n";
         //--- 
         for(int p=0;p<params;p++)
           {
            par_info+=StringFormat("parameter %d: type=%s, long_value=%d, double_value
                                   p,
                                   EnumToString((ENUM_DATATYPE)parameters[p].type),
                                   parameters[p].integer_value,
                                   parameters[p].double_value,
                                   parameters[p].string_value
                                   );
           }
         Print(par_info);
        }
      //--- Done for all indicators in the window
     }
//---    
  }
See also
ChartIndicatorGet()


--- Page 2034 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2034
IndicatorRelease
The function removes an indicator handle and releases the calculation block of the indicator, if it's not
used by anyone else.
bool  IndicatorRelease(
   int       indicator_handle     // indicator handle
   );
Return Value
Returns true in case of success, otherwise returns false.
Note
The function allows removing an indicator handle, if it's no longer needed, thus saving memory. The
handle is removed immediately, the calculation block is deleted in some time (if it's not called
anymore).
When working in the strategy tester, the IndicatorRelease() function is not executed.
Example:
//+------------------------------------------------------------------+
//|                                        Test_IndicatorRelease.mq5 |
//|                        Copyright 2010, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "2010, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.00"
//--- input parameters
input int                MA_Period=15;
input int                MA_shift=0;
input ENUM_MA_METHOD     MA_smooth=MODE_SMA;
input ENUM_APPLIED_PRICE price=PRICE_CLOSE;
//--- will store indicator handle
int MA_handle=INVALID_HANDLE;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create indicator handle
   MA_handle=iMA(Symbol(),0,MA_Period,MA_shift,MA_smooth,PRICE_CLOSE);
//--- delete global variable
   if(GlobalVariableCheck("MA_value"))
      GlobalVariableDel("MA_value");
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+


--- Page 2035 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2035
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- if the global variable value does not exist
   if(!GlobalVariableCheck("MA_value"))
     {
      //--- obtain the indicator value in the last two bars
      if(MA_handle!=INVALID_HANDLE)
        {
         //--- dynamic array for the indicator values
         double values[];
         if(CopyBuffer(MA_handle,0,0,2,values)==2 && values[0]!=EMPTY_VALUE)
           {
            //--- remember in the global variable value on the last but one bar
            if(GlobalVariableSet("MA_value",values[0]))
              {
               //--- free the handle of the indicator
               if(!IndicatorRelease(MA_handle))
                  Print("IndicatorRelease() failed. Error ",GetLastError());
               else MA_handle=INVALID_HANDLE;
              }
            else
               Print("GlobalVariableSet failed. Error ",GetLastError());
           }
        }
     }
//---
  }


--- Page 2036 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2036
CopyBuffer
Gets data of a specified buffer of a certain indicator in the necessary quantity.
Counting of elements of copied data (indicator buffer with the index buffer_num) from the starting
position is performed from the present to the past, i.e., starting position of 0 means the current bar
(indicator value for the current bar).
When copying the yet unknown amount of data, it is recommended to use a dynamic array as a
buffer[] recipient buffer, because the CopyBuffer() function tries to allocate the size of the receiving
array to the size of the copied data. If an indicator buffer (array that is pre-allocated for storing
indicator values by the SetIndexBufer() function) is used as the buffer[] recipient array, partial copying
is allowed. An example can be found in the Awesome_Oscillator.mql5 custom indicator in the standard
terminal package.
If you need to make a partial copy of the indicator values into another array (non-indicator buffer),
you should use an intermediate array, to which the desired number is copied. After that conduct the
element-wise copying of the required number of values into the required places of a receiving array
from this intermediate one.
If you know the amount of data you need to copy, it should better be done to a statically allocated
buffer, in order to prevent the allocation of excessive memory.
No matter what is the property of the target array - as_series=true or as_series=false. Data will be
copied so that the oldest element will be located at the start of the physical memory allocated for the
array. There are 3 variants of function calls.
Call by the first position and the number of required elements
int  CopyBuffer(
   int       indicator_handle,     // indicator handle
   int       buffer_num,           // indicator buffer number
   int       start_pos,            // start position
   int       count,                // amount to copy
   double    buffer[]              // target array to copy
   );
Call by the start date and the number of required elements
int  CopyBuffer(
   int       indicator_handle,     // indicator handle


--- Page 2037 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2037
   int       buffer_num,           // indicator buffer number
   datetime  start_time,           // start date and time
   int       count,                // amount to copy
   double    buffer[]              // target array to copy
   );
Call by the start and end dates of a required time interval
int  CopyBuffer(
   int       indicator_handle,     // indicator handle
   int       buffer_num,           // indicator buffer number
   datetime  start_time,           // start date and time
   datetime  stop_time,            // end date and time
   double    buffer[]              // target array to copy
   );
Parameters
indicator_handle
[in]  The indicator handle, returned by the corresponding indicator function.
buffer_num
[in]  The indicator buffer number.
start_pos
[in]  The position of the first element to copy.
count
[in]  Data count to copy.
start_time
[in]  Bar time, corresponding to the first element.
stop_time
[in]  Bar time, corresponding to the last element.
buffer[]
[out]  Array of double type.
Return Value
Returns the copied data count or -1 in case of an error.
Note
When requesting data from the indicator, if requested timeseries are not yet built or they need to
be downloaded from the server, the function will immediately return -1, but the process of
downloading/building will be initiated.
When requesting data from an Expert Advisor or script, downloading from the server will be
initiated, if  the terminal does not have these data locally, or building of a required timeseries will
start, if data can be built from the local history but they are not ready yet. The function will return
the amount of data that will be ready by the moment of timeout expiration.


--- Page 2038 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2038
Example:
//+------------------------------------------------------------------+
//|                                              TestCopyBuffer3.mq5 |
//|                        Copyright 2009, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "2009, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
//---- plot MA
#property indicator_label1  "MA"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrRed
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- input parameters
input bool               AsSeries=true;
input int                period=15;
input ENUM_MA_METHOD     smootMode=MODE_EMA;
input ENUM_APPLIED_PRICE price=PRICE_CLOSE;
input int                shift=0;
//--- indicator buffers
double                   MABuffer[];
int                      ma_handle;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- indicator buffers mapping
   SetIndexBuffer(0,MABuffer,INDICATOR_DATA);
   Print("Parameter AsSeries = ",AsSeries);
   Print("Indicator buffer after SetIndexBuffer() is a timeseries = ",
         ArrayGetAsSeries(MABuffer));
//--- set short indicator name
   IndicatorSetString(INDICATOR_SHORTNAME,"MA("+period+")"+AsSeries);
//--- set AsSeries (depends on input parameter)
   ArraySetAsSeries(MABuffer,AsSeries);
   Print("Indicator buffer after ArraySetAsSeries(MABuffer,true); is a timeseries = ",
         ArrayGetAsSeries(MABuffer));
//---
   ma_handle=iMA(Symbol(),0,period,shift,smootMode,price);
   return(INIT_SUCCEEDED);
  }


--- Page 2039 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2039
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
  {
//--- check if all data calculated
   if(BarsCalculated(ma_handle)<rates_total) return(0);
//--- we can copy not all data
   int to_copy;
   if(prev_calculated>rates_total || prev_calculated<=0) to_copy=rates_total;
   else
     {
      to_copy=rates_total-prev_calculated;
      //--- last value is always copied
      to_copy++;
     }
//--- try to copy
   if(CopyBuffer(ma_handle,0,0,to_copy,MABuffer)<=0) return(0);
//--- return value of prev_calculated for next call
   return(rates_total);
  }
//+------------------------------------------------------------------+
The above example illustrates how an indicator buffer is filled out with the values of another indicator
buffer from the indicator on the same symbol/period.
See a detailed example of history requesting data in section Methods of Object Binding. The script
available in that section shows how to get the values of indicator iFractals on the last 1000 bars and
how to display the last 10 up and 10 down fractals on the chart. A similar technique can be used for all
indicators that have missing data and that are usually drawn using the following styles:
· DRAW_SECTION,
· DRAW_ARROW,
· DRAW_ZIGZAG,
· DRAW_COLOR_SECTION,
· DRAW_COLOR_ARROW,
· DRAW_COLOR_ZIGZAG.
See also


--- Page 2040 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2040
Properties of Custom Indicators, SetIndexBuffer


--- Page 2041 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2041
CopyRates
Gets history data of MqlRates structure of a specified symbol-period in specified quantity into the
rates_array array. The elements ordering of the copied data is from present to the past, i.e., starting
position of 0 means the current bar.
When copying the yet unknown amount of data, it is recommended to use dynamic array as a target
array, because if the requested data count is less (or more) than the length of the target array,
function tries to reallocate the memory so that the requested data fit entirely.
If you know the amount of data you need to copy, it should better be done to a statically allocated
buffer, in order to prevent the allocation of excessive memory.
No matter what is the property of the target array - as_series=true or as_series=false. Data will be
copied so that the oldest element will be located at the start of the physical memory allocated for the
array. There are 3 variants of function calls.
Call by the first position and the number of required elements 
int  CopyRates(
   string           symbol_name,       // symbol name
   ENUM_TIMEFRAMES  timeframe,         // period
   int              start_pos,         // start position
   int              count,             // data count to copy
   MqlRates         rates_array[]      // target array to copy
   );
Call by the start date and the number of required elements
int  CopyRates(
   string           symbol_name,       // symbol name
   ENUM_TIMEFRAMES  timeframe,         // period
   datetime         start_time,        // start date and time
   int              count,             // data count to copy
   MqlRates         rates_array[]      // target array to copy
   );
Call by the start and end dates of a required time interval
int  CopyRates(


--- Page 2042 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2042
   string           symbol_name,       // symbol name
   ENUM_TIMEFRAMES  timeframe,         // period
   datetime         start_time,        // start date and time
   datetime         stop_time,         // end date and time
   MqlRates         rates_array[]      // target array to copy
   );
Parameters
symbol_name
[in]  Symbol name.
timeframe
[in]  Period.
start_time
[in]  Bar time for the first element to copy.
start_pos
[in]  The start position for the first element to copy.
count
[in]  Data count to copy.
stop_time
[in]  Bar time, corresponding to the last element to copy.
rates_array[]
[out]  Array of MqlRates type.
Return Value
Returns the number of copied elements or -1 in case of  an error.
Note
If the whole interval of requested data is out of the available data on the server, the function
returns -1. If data outside TERMINAL_MAXBARS (maximal number of bars on the chart) is requested,
the function will also return -1.
When requesting data from the indicator, if requested timeseries are not yet built or they need to
be downloaded from the server, the function will immediately return -1, but the process of
downloading/building will be initiated.
When requesting data from an Expert Advisor or script, downloading from the server will be
initiated, if  the terminal does not have these data locally, or building of a required timeseries will
start, if data can be built from the local history but they are not ready yet. The function will return
the amount of data that will be ready by the moment of timeout expiration, but history downloading
will continue, and at the next similar request the function will return more data.
When requesting data by the start date and the number of required elements, only data whose date
is less than (earlier) or equal to the date specified will be returned. It means, the open time of any
bar, for which value is returned (volume, spread, value on the indicator buffer, prices Open, High,
Low, Close or open time Time) is always less or equal to the specified one.


--- Page 2043 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2043
When requesting data in a specified range of dates, only data from this interval will be returned.
The interval is set and counted up to seconds. It means, the open time of any bar, for which value is
returned (volume, spread, value on the indicator buffer, prices Open, High, Low, Close or open time
Time) is always within the requested interval. 
Thus, if the current day is Saturday, at the attempt to copy data on a week timeframe specifying
start_time=Last_Tuesday and stop_time=Last_Friday the function will return 0, because the open
time on a week timeframe is always Sunday, but one week bar does not fall into the specified
interval.
If you need to return value corresponding to the current uncompleted bar, you can use the first form
of call specifying start_pos=0 and count=1.
Example:
void OnStart()
  {
//---
   MqlRates rates[];
   ArraySetAsSeries(rates,true);
   int copied=CopyRates(Symbol(),0,0,100,rates);
   if(copied>0)
     {
      Print("Bars copied: "+copied);
      string format="open = %G, high = %G, low = %G, close = %G, volume = %d";
      string out;
      int size=fmin(copied,10);
      for(int i=0;i<size;i++)
        {
         out=i+":"+TimeToString(rates[i].time);
         out=out+" "+StringFormat(format,
                                  rates[i].open,
                                  rates[i].high,
                                  rates[i].low,
                                  rates[i].close,
                                  rates[i].tick_volume);
         Print(out);
        }
     }
   else Print("Failed to get history data for the symbol ",Symbol());
  }
See a detailed example of requesting history data in section Methods of Object Binding. The script
available in that section shows how to get the values of indicator iFractals on the last 1000 bars and
how to display the last 10 up and 10 down fractals on the chart. A similar technique can be used for all
indicators that have missing data and that are usually drawn using the following styles:
· DRAW_SECTION,
· DRAW_ARROW,
· DRAW_ZIGZAG,
· DRAW_COLOR_SECTION,


--- Page 2044 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2044
· DRAW_COLOR_ARROW,
· DRAW_COLOR_ZIGZAG.
See also
Structures and Classes,  TimeToString, StringFormat


--- Page 2045 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2045
CopySeries
Gets the synchronized timeseries from the MqlRates structure for the specified symbol-period and the
specified amount. The data is received into the specified set of arrays. Elements are counted down
from the present to the past, which means that the starting position equal to 0 means the current bar.
If the data amount to be copied is unknown, it is recommended to use the dynamic array for the
receiving arrays, since if the data amount exceeds what an array can contain, this can cause the
attempt to redistribute the array to fit all of the requested data.
If you need to copy a predetermined amount of data, it is recommended to use a statistically allocated
buffer to avoid unnecessary memory reallocation.
The property of the receiving array — as_series=true or as_series=false — will be ignored: during
copying, the oldest timeseries element will be copied to the beginning of the physical memory
allocated for the array.
int  CopySeries(
   string           symbol_name,       // symbol name
   ENUM_TIMEFRAMES  timeframe,         // period
   int              start_pos,         // start position
   int              count,             // amount to copy
   ulong            rates_mask,        // combination of flags to specify the requeste
   void&            array1[],          // array to receive the data of the first copie
   void&            array2[]           // array to receive the data of the second copi
   ...
   );


--- Page 2046 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2046
Parameters
symbol_name
[in]  Symbol.
timeframe
[in]  Period.
start_pos
[in]  First copied element index.
count
[in]  Number of copied elements.
rates_mask
[in]  A combination of flags from the ENUM_COPY_RATES enumeration.
array1, array2,...
[out]  Array of the appropriate type to receive the timeseries from the MqlRates structure. The
order of the arrays passed to the function must match the order of the fields in the MqlRates
structure. 
Return Value
The number of copied elements or -1 if error occurs.
Note
If the entire interval of the requested data is beyond the data available on the server, the function
returns -1. If the requested data is beyond TERMINAL_MAXBARS (the maximum number of bars on
the chart), the function also returns -1.
When requesting data from an indicator, the function immediately returns -1 if requested
timeseries are not constructed yet or they should be downloaded from the server. However, this will
initiate data download/constructing itself.
When requesting data from an Expert Advisor or a script, download from the server is initiated if
the terminal does not have the appropriate data locally, or construction of the necessary timeseries
starts if the data can be constructed from the local history but they are not ready yet. The function
returns the amount of data that is ready by the time the timeout expires, however the history
download continues, and the function returns more data during the next similar request.
Difference between CopySeries and CopyRates
The CopySeries function allows obtaining only the necessary timeseries into different specified arrays
during one call, while all of timeseries data will be synchronized. This means that all values in the
resulting arrays at a certain index N will belong to the same bar on the specified Symbol/Timeframe
pair. Therefore, there is no need for the programmer to ensure the synchronization of all received
timeseries by the bar opening time.
Unlike CopyRates, which returns the full set of timeseries as an MqlRates array, the CopySeries
function allows the programmer to get only the required timeseries as separate arrays. This can be


--- Page 2047 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2047
done by specifying a combination of flags to select the type of timeseries. The order of the arrays
passed to the function must match the order of the fields in the MqlRates structure:
struct MqlRates
  {
   datetime time;         // period start time
   double   open;         // open price
   double   high;         // high price for the period
   double   low;          // low price for the period
   double   close;        // close price
   long     tick_volume;  // tick volume
   int      spread;       // spread
   long     real_volume;  // exchange volume
  }
Thus, if you need to get the values of the time, close and real_volume timeseries for the last 100 bars
of the current Symbol/Timeframe, you should use the following call:
datetime time[];
double   close[];
long     volume[];
CopySeries(NULL,0,0,100,COPY_RATES_TIME|COPY_RATES_CLOSE|COPY_RATES_VOLUME_REAL,time,c
Mind the order of the arrays "time, close, volume" — it must match the order of the fields in the 
MqlRates structure. The order of values in the rates_mask does not matter. The mask could be as
follows:
COPY_RATES_VOLUME_REAL|COPY_RATES_TIME|COPY_RATES_CLOSE
Example:
//--- input parameters
input datetime InpDateFrom=D'2022.01.01 00:00:00';
input datetime InpDateTo  =D'2023.01.01 00:00:00';
input uint     InpCount   =20;
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart(void)
  {
//--- arrays to get timeseries from the MqlRates price structure
   double   open[];
   double   close[];
   float    closef[];
   datetime time1[], time2[];
//--- request close prices to a double array
   ResetLastError();
   int res1=CopySeries(NULL, PERIOD_CURRENT, 0, InpCount,
                       COPY_RATES_TIME|COPY_RATES_CLOSE, time1, close);
   PrintFormat("1. CopySeries  returns %d values. Error code=%d", res1, GetLastError()


--- Page 2048 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2048
   ArrayPrint(close);
  
//--- now also request open prices; use float array for close prices
   ResetLastError();
   int res2=CopySeries(NULL, PERIOD_CURRENT, 0, InpCount,
                       COPY_RATES_TIME|COPY_RATES_CLOSE|COPY_RATES_OPEN, time2, open, 
   PrintFormat("2. CopySeries  returns %d values. Error code=%d", res2, GetLastError()
   ArrayPrint(closef);
//--- Compare the received data
   if((res1==res2) && (time1[0]==time2[0]))
     {
      Print("  | Time             |    Open      | Close double | Close float |");
      for(int i=0; i<10; i++)
        {
         PrintFormat("%d | %s |   %.5f    |   %.5f    |   %.5f   |",
                     i, TimeToString(time1[i]), open[i], close[i], closef[i]);
        }
     }
//--- Result
1. CopySeries  returns 20 values. Error code=0
[ 0] 1.06722 1.06733 1.06653 1.06520 1.06573 1.06649 1.06694 1.06675 1.06684 1.0
[10] 1.06514 1.06557 1.06456 1.06481 1.06414 1.06394 1.06364 1.06386 1.06239 1.0
2. CopySeries  returns 20 values. Error code=0
[ 0] 1.06722 1.06733 1.06653 1.06520 1.06573 1.06649 1.06694 1.06675 1.06684 1.0
[10] 1.06514 1.06557 1.06456 1.06481 1.06414 1.06394 1.06364 1.06386 1.06239 1.0
  | Time             |    Open      | Close double | Close float |
0 | 2023.03.01 17:00 |   1.06660    |   1.06722    |   1.06722   |
1 | 2023.03.01 18:00 |   1.06722    |   1.06733    |   1.06733   |
2 | 2023.03.01 19:00 |   1.06734    |   1.06653    |   1.06653   |
3 | 2023.03.01 20:00 |   1.06654    |   1.06520    |   1.06520   |
4 | 2023.03.01 21:00 |   1.06520    |   1.06573    |   1.06573   |
5 | 2023.03.01 22:00 |   1.06572    |   1.06649    |   1.06649   |
6 | 2023.03.01 23:00 |   1.06649    |   1.06694    |   1.06694   |
7 | 2023.03.02 00:00 |   1.06683    |   1.06675    |   1.06675   |
8 | 2023.03.02 01:00 |   1.06675    |   1.06684    |   1.06684   |
9 | 2023.03.02 02:00 |   1.06687    |   1.06604    |   1.06604   |
//---
  }
See also
Structures and classes,  CopyRates


--- Page 2049 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2049
CopyTime
The function gets to time_array history data of bar opening time for the specified symbol-period pair
in the specified quantity. It should be noted that elements ordering is from present to past, i.e.,
starting position of 0 means the current bar.
When copying the yet unknown amount of data, it is recommended to use dynamic array as a target
array, because if the requested data count is less (or more) than the length of the target array,
function tries to reallocate the memory so that the requested data fit entirely.
If you know the amount of data you need to copy, it should better be done to a statically allocated
buffer, in order to prevent the allocation of excessive memory.
No matter what is the property of the target array - as_series=true or as_series=false. Data will be
copied so that the oldest element will be located at the start of the physical memory allocated for the
array. There are 3 variants of function calls.
Call by the first position and the number of required elements 
int  CopyTime(
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   int              start_pos,       // start position
   int              count,           // data count to copy
   datetime         time_array[]     // target array to copy open times
   );
Call by the start date and the number of required elements 
int  CopyTime(
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   datetime         start_time,      // start date and time
   int              count,           // data count to copy
   datetime         time_array[]     // target array to copy  open times
   );
Call by the start and end dates of a required time interval
int  CopyTime(


--- Page 2050 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2050
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   datetime         start_time,      // start date and time
   datetime         stop_time,       // stop date and time
   datetime         time_array[]     // target array to copy open times
   );
Parameters
symbol_name
[in]  Symbol name.
timeframe
[in]  Period.
start_pos
[in]  The start position for the first element to copy.
count
[in]  Data count to copy.
start_time
[in]  The start time for the first element to copy.
stop_time
[in]  Bar time corresponding to the last element to copy.
time_array[]
[out]  Array of datetime type.
Return Value
Returns the copied data count or -1 in case of an error.
Note
If the whole interval of requested data is out of the available data on the server, the function
returns -1. If data outside TERMINAL_MAXBARS (maximal number of bars on the chart) is requested,
the function will also return -1.
When requesting data from the indicator, if requested timeseries are not yet built or they need to
be downloaded from the server, the function will immediately return -1, but the process of
downloading/building will be initiated.
When requesting data from an Expert Advisor or script, downloading from the server will be
initiated, if  the terminal does not have these data locally, or building of a required timeseries will
start, if data can be built from the local history but they are not ready yet. The function will return
the amount of data that will be ready by the moment of timeout expiration, but history downloading
will continue, and at the next similar request the function will return more data.
When requesting data by the start date and the number of required elements, only data whose date
is less than (earlier) or equal to the date specified will be returned. It means, the open time of any
bar, for which value is returned (volume, spread, value on the indicator buffer, prices Open, High,
Low, Close or open time Time) is always less or equal to the specified one.


--- Page 2051 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2051
When requesting data in a specified range of dates, only data from this interval will be returned.
The interval is set and counted up to seconds. It means, the open time of any bar, for which value is
returned (volume, spread, value on the indicator buffer, prices Open, High, Low, Close or open time
Time) is always within the requested interval. 
Thus, if the current day is Saturday, at the attempt to copy data on a week timeframe specifying
start_time=Last_Tuesday and stop_time=Last_Friday the function will return 0, because the open
time on a week timeframe is always Sunday, but one week bar does not fall into the specified
interval.
If you need to return value corresponding to the current uncompleted bar, you can use the first form
of call specifying start_pos=0 and count=1.
See a detailed example of requesting history data in section Methods of Object Binding. The script
available in that section shows how to get the values of indicator iFractals on the last 1000 bars and
how to display the last 10 up and 10 down fractals on the chart. A similar technique can be used for all
indicators that have missing data and that are usually drawn using the following styles:
· DRAW_SECTION,
· DRAW_ARROW,
· DRAW_ZIGZAG,
· DRAW_COLOR_SECTION,
· DRAW_COLOR_ARROW,
· DRAW_COLOR_ZIGZAG.


--- Page 2052 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2052
CopyOpen
The function gets into open_array the history data of bar open prices for the selected symbol-period
pair in the specified quantity. It should be noted that elements ordering is from present to past, i.e.,
starting position of 0 means the current bar.
When copying the yet unknown amount of data, it is recommended to use dynamic array as a target
array, because if the requested data count is less (or more) than the length of the target array,
function tries to reallocate the memory so that the requested data fit entirely.
If you know the amount of data you need to copy, it should better be done to a statically allocated
buffer, in order to prevent the allocation of excessive memory.
No matter what is the property of the target array - as_series=true or as_series=false. Data will be
copied so that the oldest element will be located at the start of the physical memory allocated for the
array. There are 3 variants of function calls.
Call by the first position and the number of required elements  
int  CopyOpen(
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   int              start_pos,       // start position
   int              count,           // data count to copy
   double           open_array[]     // target array to copy open prices
   );
Call by the start date and the number of required elements 
int  CopyOpen(
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   datetime         start_time,      // start date and time
   int              count,           // data count to copy
   double           open_array[]     // target array for bar open prices
   );
Call by the start and end dates of a required time interval
int  CopyOpen(


--- Page 2053 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2053
   string           symbol_name,     // symbol name
   ENUM_TIMEFRAMES  timeframe,       // period
   datetime         start_time,      // start date and time
   datetime         stop_time,       // stop date and time
   double           open_array[]     // target array for bar open values
   );
Parameters
symbol_name
[in]  Symbol name.
timeframe
[in]  Period.
start_pos
[in]  The start position for the first element to copy.
count
[in]  Data count to copy.
start_time
[in]  The start time for the first element to copy.
stop_time
[in]  The start time for the last element to copy.
open_array[]
[out]  Array of double type.
Return Value
Returns the number of element in the array or -1 in case of an error.
Note
If the whole interval of requested data is out of the available data on the server, the function
returns -1. If data outside TERMINAL_MAXBARS (maximal number of bars on the chart) is requested,
the function will also return -1.
When requesting data from the indicator, if requested timeseries are not yet built or they need to
be downloaded from the server, the function will immediately return -1, but the process of
downloading/building will be initiated.
When requesting data from an Expert Advisor or script, downloading from the server will be
initiated, if  the terminal does not have these data locally, or building of a required timeseries will
start, if data can be built from the local history but they are not ready yet. The function will return
the amount of data that will be ready by the moment of timeout expiration, but history downloading
will continue, and at the next similar request the function will return more data.
When requesting data by the start date and the number of required elements, only data whose date
is less than (earlier) or equal to the date specified will be returned. It means, the open time of any
bar, for which value is returned (volume, spread, value on the indicator buffer, prices Open, High,
Low, Close or open time Time) is always less or equal to the specified one.


--- Page 2054 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2054
When requesting data in a specified range of dates, only data from this interval will be returned.
The interval is set and counted up to seconds. It means, the open time of any bar, for which value is
returned (volume, spread, value on the indicator buffer, prices Open, High, Low, Close or open time
Time) is always within the requested interval. 
Thus, if the current day is Saturday, at the attempt to copy data on a week timeframe specifying
start_time=Last_Tuesday and stop_time=Last_Friday the function will return 0, because the open
time on a week timeframe is always Sunday, but one week bar does not fall into the specified
interval.
If you need to return value corresponding to the current uncompleted bar, you can use the first form
of call specifying start_pos=0 and count=1.
See a detailed example of requesting history data in section Methods of Object Binding. The script
available in that section shows how to get the values of indicator iFractals on the last 1000 bars and
how to display the last 10 up and 10 down fractals on the chart. A similar technique can be used for all
indicators that have missing data and that are usually drawn using the following styles:
· DRAW_SECTION,
· DRAW_ARROW,
· DRAW_ZIGZAG,
· DRAW_COLOR_SECTION,
· DRAW_COLOR_ARROW,
· DRAW_COLOR_ZIGZAG.


--- Page 2055 ---
Timeseries and Indicators Access
© 2000-2025, MetaQuotes Ltd.
2055
CopyHigh
The function gets into high_array the history data of highest bar prices for the selected symbol-period
pair in the specified quantity. It should be noted that elements ordering is from present to past, i.e.,
starting position of 0 means the current bar.
When copying the yet unknown amount of data, it is recommended to use dynamic array as a target
array, because if the requested data count is less (or more) than the length of the target array,
function tries to reallocate the memory so that the requested data fit entirely.
If you know the amount of data you need to copy, it should better be done to a statically allocated
buffer, in order to prevent the allocation of excessive memory.
No matter what is the property of the target array - as_series=true or as_series=false. Data will be
copied so that the oldest element will be located at the start of the physical memory allocated for the
array. There are 3 variants of function calls.
Call by the first position and the number of required elements 
int  CopyHigh(
   string           symbol_name,      // symbol name
   ENUM_TIMEFRAMES  timeframe,        // period
   int              start_pos,        // start position
   int              count,            // data count to copy
   double           high_array[]      // target array to copy
   );
Call by the start date and the number of required elements 
int  CopyHigh(
   string           symbol_name,      // symbol name
   ENUM_TIMEFRAMES  timeframe,        // period
   datetime         start_time,       // start date and time
   int              count,            // data count to copy
   double           high_array[]      // target array to copy
   );
Call by the start and end dates of a required time interval
int  CopyHigh(
