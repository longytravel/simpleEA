=== Event Handling (Pages 1887-1947) ===

--- Page 1887 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1887
Event Handling
The MQL5 language provides handling of certain predefined events. The functions for handling these
events should be defined in an MQL5 program: function name, return type, a set of parameters (if
any) and their types should strictly correspond to the description of an event handling function.
The client terminal event handler uses the return and parameter types to identify functions processing
an event. If a certain function has some parameters or a return type not corresponding to the
descriptions below, such a function cannot be used for handling an event.
Function
Description
OnStart
The function is called when the Start event occurs to perform
actions set in the script
OnInit
The function is called in indicators and EAs when the Init event
occurs to initialize a launched MQL5 program
OnDeinit
The function is called in indicators and EAs when the Deinit event
occurs to de-initialize a launched MQL5 program
OnTick
The function is called in EAs when the NewTick event occurs to
handle a new quote
OnCalculate
The function is called in indicators when the Calculate event occurs
to handle price data changes
OnTimer
The function is called in indicators and EAs during the Timer
periodic event generated by the terminal at fixed time intervals
OnTrade
The function is called in EAs during the Trade event generated at
the end of a trading operation on a trade server
OnTradeTransaction
The function is called in EAs when the TradeTransaction event
occurs to process a trade request execution results
OnBookEvent
The function is called in EAs when the BookEvent event occurs to
process changes in the market depth
OnChartEvent
The function is called in indicators and EAs when the ChartEvent
event occurs to process chart changes made by a user or an MQL5
program
OnTester
The function is called in EAs when the Tester event occurs to
perform necessary actions after testing an EA on history data
OnTesterInit
The function is called in EAs when the TesterInit event occurs to
perform necessary actions before optimization in the strategy
tester
OnTesterDeinit
The function is called in EAs when the TesterDeinit event occurs
after EA optimization in the strategy tester
OnTesterPass
The function is called in EAs when the TesterPass even occurs to
handle an arrival of a new data frame during EA optimization in the
strategy tester


--- Page 1888 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1888
The client terminal sends incoming events to corresponding open charts. Also, events may be
generated by charts (chart events) or mql5 programs (custom events). Generating graphical object
creation/deletion events can be enabled/disabled by setting the CHART_EVENT_OBJECT_CREATE and
CHART_EVENT_OBJECT_DELETE chart properties. Each mql5 application and chart have their own
queue of events where all newly arrived events are placed.
A program gets events only from the chart it is running on. All events are handled one after another in
the order of their receipt. If the queue already contains the NewTick event or this event is in the
processing stage, then the new NewTick event is not added to mql5 application queue. Similarly, if the
ChartEvent is already in an mql5 program queue or such an event is being handled, then a new event
of this type is not placed into a queue. Timer event handling is processed in the same way – if the
Timer event is already in the queue or is being handled, no new timer event is set into a queue.
Event queues have a limited but sufficient size, so the queue overflow is unlikely for a correctly
developed program. When the queue overflows, new events are discarded without being set into a
queue.
It is strongly recommended not to use infinite loops to handle events. Possible exceptions are scripts
handling a single Start event.
Libraries do not handle any events.


--- Page 1889 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1889
OnStart
The function is called in scripts and services when the Start event occurs. The function is intended for
one-time execution of actions implemented in a program. There are two function types.
The version that returns the result
int  OnStart(void);
Return Value
The value of int type displayed in the Journal tab.
The entry "script script_name removed (result code N)" is created in the terminal journal after a
script execution is complete. Here N is a value returned by the OnStart() function.
The entry "service service_name stopped (result code N)" is created in the terminal journal after a
service execution is complete. Here N is a value returned by the OnStart() function.
The OnStart() call that returns the execution result is recommended for use since it not only allows for
a script or service execution, but also returns an error code or other useful data to analyze the
program execution result.
The version without a result return is left only for compatibility with old codes. It is not
recommended for use
void  OnStart(void);
Note
OnStart() is the only function for handling events in scripts and services. No other events are sent to
these programs. In turn, the Start event is not passed to EAs and custom indicators.
Sample script:
//--- macros for working with colors
#define XRGB(r,g,b)    (0xFF000000|(uchar(r)<<16)|(uchar(g)<<8)|uchar(b))
#define GETRGB(clr)    ((clr)&0xFFFFFF)
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- set a downward candle color
   Comment("Set a downward candle color"); 
   ChartSetInteger(0,CHART_COLOR_CANDLE_BEAR,GetRandomColor());
   ChartRedraw(); // update the chart immediately without waiting for a new tick
   Sleep(1000);   // pause for 1 second to see all the changes
//--- set an upward candle color
   Comment("Set an upward candle color"); 
   ChartSetInteger(0,CHART_COLOR_CANDLE_BULL,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set the background color


--- Page 1890 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1890
   Comment("Set the background color"); 
   ChartSetInteger(0,CHART_COLOR_BACKGROUND,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set color of Ask line
   Comment("Set color of Ask line"); 
   ChartSetInteger(0,CHART_COLOR_ASK,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set color of Bid line
   Comment("Set color of Bid line"); 
   ChartSetInteger(0,CHART_COLOR_BID,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);    
//--- set color of a downward bar and a downward candle frame
   Comment("Set color of a downward bar and a downward candle frame"); 
   ChartSetInteger(0,CHART_COLOR_CHART_DOWN,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set color of a chart line and Doji candlesticks
   Comment("Set color of a chart line and Doji candlesticks"); 
   ChartSetInteger(0,CHART_COLOR_CHART_LINE,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set color of an upward bar and an upward candle frame  
   Comment("Set color of an upward bar and an upward candle frame"); 
   ChartSetInteger(0,CHART_COLOR_CHART_UP,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set color of axes, scale and OHLC line
   Comment("Set color of axes, scale and OHLC line"); 
   ChartSetInteger(0,CHART_COLOR_FOREGROUND,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set a grid color
   Comment("Set a grid color"); 
   ChartSetInteger(0,CHART_COLOR_GRID,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set Last price color
   Comment("Set Last price color"); 
   ChartSetInteger(0,CHART_COLOR_LAST,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   
//--- set color of Stop Loss and Take Profit order levels
   Comment("Set color of Stop Loss and Take Profit order levels"); 
   ChartSetInteger(0,CHART_COLOR_STOP_LEVEL,GetRandomColor());
   ChartRedraw(); 
   Sleep(1000);   


--- Page 1891 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1891
//--- set color of volumes and market entry levels
   Comment("Set color of volumes and market entry levels"); 
   ChartSetInteger(0,CHART_COLOR_VOLUME,GetRandomColor());
   ChartRedraw();
  }
//+------------------------------------------------------------------+
//| Return a randomly generated color                                |
//+------------------------------------------------------------------+
color GetRandomColor()
  {
   color clr=(color)GETRGB(XRGB(rand()%255,rand()%255,rand()%255));
   return clr;
  }
See also
Event handling functions, Program running, Client terminal events


--- Page 1892 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1892
OnInit
The function is called in indicators and EAs when the Init event occurs. It is used to initialize a running
MQL5 program. There are two function types.
The version that returns the result
int  OnInit(void);
Return Value
int type value, zero means successful initialization.
When returning INIT_FAILED, the EA is forcibly unloaded from the chart. 
When returning INIT_FAILED, the indicator is not unloaded from the chart. The indicator remaining
on the chart is non-operational — event handlers are not called in the indicator. 
The OnInit() call that returns the execution result is recommended for use since it not only allows for
program initialization, but also returns an error code in case of an early program termination.
The version without a result return is left only for compatibility with old codes. It is not
recommended for use
void  OnInit(void);
Note
The Init event is generated immediately after loading an EA or an indicator. The event is not
generated for scripts. The OnInit() function is used to initialize an MQL5 program. If OnInit() has a
return value of int type, the non-zero return code means failed initialization and generates the
Deinit event with the REASON_INITFAILED deinitialization reason code.
OnInit() function of void type always means successful initialization and is not recommended for
use.
For optimizing the EA inputs, it is recommended to use values from the ENUM_INIT_RETCODE
enumeration as a return code. These values are intended for establishing the optimization process
management, including selection of the most suitable test agents. It is possible to request data on
agent configuration and resources (number of cores, free memory amount, etc.) using the
TerminalInfoInteger() function during the EA initialization before launching the test. Based on the
obtained data, you can either allow using the test agent or ban it from optimizing the EA.
ID
Description
INIT_SUCCEEDED
Initialization successful, EA test can be continued.
This code means the same as the zero value – the EA
initialization in the tester is successful.
INIT_FAILED
Initialization failed. There is no point in continuing the test due
to unavoidable errors. For example, it is impossible to create
an indicator necessary for the EA operation.
The return of this value means the same as returning the value
different from zero – EA initialization in the tester failed.


--- Page 1893 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1893
ID
Description
INIT_PARAMETERS_INCORRECT
Designed to denote an incorrect set of input parameters by a
programmer. In the general optimization table, the result string
with this return code is highlighted in red.
A test for such a set of EA inputs is not performed. The agent
is ready to receive a new task.
When this value is received, the strategy tester does not pass
this task to other agents for repeated execution.
INIT_AGENT_NOT_SUITABLE
No program execution errors during initialization. However, for
some reasons, the agent is not suitable for conducting a test.
For example, there is not enough RAM, no OpenCL support,
etc. 
After returning this code, the agent no longer receives tasks
until the very end of this optimization.
Using OnInit() returning INIT_FAILED/INIT_PARAMETERS_INCORRECT in the tester have some
peculiarities that should be considered when optimizing EAs:
· the set of parameters the OnInit() returned INIT_PARAMETERS_INCORRECT for is considered
unsuitable for testing and is not used to obtain the next population during genetic optimization.
Too many "discarded" parameter sets may lead to incorrect results when searching for optimal EA
parameters. The search algorithm assumes that the optimization criterion function is smooth and
has no gaps on the entire multitude of input parameters.
· if OnInit() returns INIT_FAILED, this means that a test cannot be launched, and the EA is unloaded
from the agent's memory. The EA is loaded again to perform the next pass with a new set of
parameters. Launching the next optimization pass takes much more time as compared to calling
TesterStop().
Sample OnInit() function for an EA
//--- input parameters
input int      ma_period=20; // moving average period
//--- handle of the indicator used in the EA
int indicator_handle;   
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- check ma_period validity
   if(ma_period<=0)
     {
      PrintFormat("Invalid ma_period input value: %d",ma_period);
      return (INIT_PARAMETERS_INCORRECT);
     }
//--- during optimization
   if(MQLInfoInteger(MQL_OPTIMIZATION))
     {


--- Page 1894 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1894
      //--- check available RAM for the agent
      int available_memory_mb=TerminalInfoInteger(TERMINAL_MEMORY_TOTAL);
      if(available_memory_mb<2000)
        {
         PrintFormat("Insufficient memory for the test agent: %d MB",
                     available_memory_mb);
         return (INIT_AGENT_NOT_SUITABLE);
        }
     }
//--- check for the indicator
   indicator_handle=iCustom(_Symbol,_Period,"My_Indicator",ma_period);
   if(indicator_handle==INVALID_HANDLE)
     {
      PrintFormat("Failed to generate My_Indicator handle. Error code %d",
                  GetLastError());
      return (INIT_FAILED);
     }
//--- EA initialization successful
   return(INIT_SUCCEEDED);
  }
See also
OnDeinit, Event handling functions, Program running, Client terminal events, Initialization of
variables, Creating and deleting objects


--- Page 1895 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1895
OnDeinit
The function is called in indicators and EAs when the Deinit event occurs. It is used to deinitialize a
running MQL5 program.
void  OnDeinit(
   const int  reason         // deinitialization reason code
   );
Parameters
reason
[in]  Deinitialization reason code.
Return Value
No return value
Note
Deinit event is generated for EAs and indicators in the following cases:
· before a re-initialization due to the change of a symbol or a chart period the mql5 program is
attached to;
· before a re-initialization due to the change of the inputs;
· before unloading an mql5 program.
The reason parameter may have the following values:
Constant
Value
Description
REASON_PROGRAM
0
The 
EA 
has 
stopped 
working 
calling 
the
ExpertRemove() function
REASON_REMOVE
1
Program removed from a chart
REASON_RECOMPILE
2
Program recompiled
REASON_CHARTCHANGE
3
A symbol or a chart period is changed
REASON_CHARTCLOSE
4
Chart closed
REASON_PARAMETERS
5
Inputs changed by a user
REASON_ACCOUNT
6
Another account has been activated or reconnection
to the trade server has occurred due to changes in
the account settings
REASON_TEMPLATE
7
Another chart template applied
REASON_INITFAILED
8
The OnInit() handler returned a non-zero value
REASON_CLOSE
9
Terminal closed
EA deinitialization reason codes can be received by the UninitializeReason() function or from the
predefined _UninitReason variable.
Sample OnInit() and OnDeinit() functions for the EA


--- Page 1896 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1896
input int fake_parameter=3;      // useless parameter
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- Get the number of a build where the program is compiled
   Print(__FUNCTION__," Build #",__MQLBUILD__);
//--- Reset reason code can also be obtained in OnInit()
   Print(__FUNCTION__," Deinitialization reason code can be received during the EA res
//--- The first way to get a deinitialization reason code
   Print(__FUNCTION__," _UninitReason = ",getUninitReasonText(_UninitReason));
//--- The second way to get a deinitialization reason code  
   Print(__FUNCTION__," UninitializeReason() = ",getUninitReasonText(UninitializeReaso
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- The first way to get a deinitialization reason code
   Print(__FUNCTION__," Deinitialization reason code = ",reason);
//--- The second way to get a deinitialization reason code
   Print(__FUNCTION__," _UninitReason = ",getUninitReasonText(_UninitReason));
//--- The third way to get a deinitialization reason code  
   Print(__FUNCTION__," UninitializeReason() = ",getUninitReasonText(UninitializeReaso
  }
//+------------------------------------------------------------------+
//| Return a textual description of the deinitialization reason code |
//+------------------------------------------------------------------+
string getUninitReasonText(int reasonCode)
  {
   string text="";
//---
   switch(reasonCode)
     {
      case REASON_ACCOUNT:
         text="Account was changed";break;
      case REASON_CHARTCHANGE:
         text="Symbol or timeframe was changed";break;
      case REASON_CHARTCLOSE:
         text="Chart was closed";break;
      case REASON_PARAMETERS:
         text="Input-parameter was changed";break;
      case REASON_RECOMPILE:
         text="Program "+__FILE__+" was recompiled";break;


--- Page 1897 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1897
      case REASON_REMOVE:
         text="Program "+__FILE__+" was removed from chart";break;
      case REASON_TEMPLATE:
         text="New template was applied to chart";break;
      default:text="Another reason";
     }
//---
   return text;
  }
See also
OnInit, Event handling functions, Program running, Client terminal events, Uninitialization reason
codes, Visibility scope and lifetime of variables, Creating and deleting objects


--- Page 1898 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1898
OnTick
The function is called in EAs when the NewTick event occurs to handle a new quote.
void  OnTick(void);
Return Value
No return value
Note
The NewTick event is generated only for EAs upon receiving a new tick for a symbol of the chart the
EA is attached to. There is no point in defining the OnTick() function in a custom indicator or a
script since a NewTick event is not generated for them. 
The Tick event is generated only for EAs, but this does not mean that EAs have to feature the
OnTick() function, since Timer, BookEvent and ChartEvent events are also generated for EAs in
addition to NewTick.
All events are handled one after another in the order of their receipt. If the queue already contains
the NewTick event or this event is in the processing stage, then the new NewTick event is not added
to mql5 application queue.
The NewTick event is generated regardless of whether auto trading is enabled (AutoTrading button).
Disabled auto trading means only a ban on sending trade requests from an EA. The EA operation is
not stopped.
Disabling auto trading by pressing the AutoTrading button does not interrupt the current execution
of the OnTick() function.
Example of the EA featuring its entire trading logic in the OnTick() function
//+------------------------------------------------------------------+
//|                                                   TradeByATR.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2000-2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property description "Sample EA trading in the \"explosive\" candle direction"
#property description "\"Explosive\" candle has the body size exceeding k*ATR"
#property description "The \"revers\" parameter reverses the signal direction"
input double lots=0.1;        // volume in lots
input double kATR=3;          // signal candle length in ATR
input int    ATRperiod=20;    // ATR indicator period
input int    holdbars=8;      // number of bars to hold position on
input int    slippage=10;     // allowable slippage
input bool   revers=false;    // reverse the signal? 
input ulong  EXPERT_MAGIC=0;  // EA's MagicNumber
//--- for storing the ATR indicator handle


--- Page 1899 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1899
int atr_handle;
//--- here we will store the last ATR values and the candle body
double last_atr,last_body;
datetime lastbar_timeopen;
double trade_lot;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- initialize global variables
   last_atr=0;
   last_body=0;
//--- set the correct volume
   double min_lot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   trade_lot=lots>min_lot? lots:min_lot;   
//--- create ATR indicator handle
   atr_handle=iATR(_Symbol,_Period,ATRperiod);
   if(atr_handle==INVALID_HANDLE)
     {
      PrintFormat("%s: failed to create iATR, error code %d",__FUNCTION__,GetLastError
      return(INIT_FAILED);
     }
//--- successful EA initialization
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- inform of the EA operation end code
   Print(__FILE__,": Deinitialization reason code = ",reason);
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- trading signal
   static int signal=0; // +1 means a buy signal, -1 means a sell signal
//--- check and close old positions opened more than 'holdbars' bars ago
   ClosePositionsByBars(holdbars,slippage,EXPERT_MAGIC);
//--- check for a new bar
   if(isNewBar())
     {
      //--- check for a signal presence      
      signal=CheckSignal();
     }


--- Page 1900 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1900
//--- if a netting position is opened, skip the signal - wait till it closes
   if(signal!=0 && PositionsTotal()>0 && (ENUM_ACCOUNT_MARGIN_MODE)AccountInfoInteger
     {
      signal=0;
      return; // exit the NewTick event handler and do not enter the market before a n
     }
//--- for a hedging account, each position is held and closed separately
   if(signal!=0)
     {
      //--- buy signal
      if(signal>0)
        {
         PrintFormat("%s: Buy signal! Revers=%s",__FUNCTION__,string(revers));
         if(Buy(trade_lot,slippage,EXPERT_MAGIC))
            signal=0;
        }
      //--- sell signal
      if(signal<0)
        {
         PrintFormat("%s: Sell signal! Revers=%s",__FUNCTION__,string(revers));
         if(Sell(trade_lot,slippage,EXPERT_MAGIC))
            signal=0;
        }
     }
//--- OnTick function end
  }
//+------------------------------------------------------------------+
//| Check for a new trading signal                                   |
//+------------------------------------------------------------------+
int CheckSignal()
  {
//--- 0 means no signal
   int res=0;
//--- get ATR value on a penultimate complete bar (the bar index is 2)
   double atr_value[1];
   if(CopyBuffer(atr_handle,0,2,1,atr_value)!=-1)
     {
      last_atr=atr_value[0];
      //--- get data on the last closed bar to the MqlRates type array
      MqlRates bar[1];
      if(CopyRates(_Symbol,_Period,1,1,bar)!=-1)
        {
         //--- calculate the bar body size on the last complete bar
         last_body=bar[0].close-bar[0].open;
         //--- if the body of the last bar (with index 1) exceeds the previous ATR val
         if(MathAbs(last_body)>kATR*last_atr)
            res=last_body>0?1:-1; // positive value for the upward candle
        }
      else


--- Page 1901 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1901
         PrintFormat("%s: Failed to receive the last bar! Error",__FUNCTION__,GetLastE
     }
   else
      PrintFormat("%s: Failed to receive ATR indicator value! Error",__FUNCTION__,GetL
//--- if reverse trading mode is enabled
   res=revers?-res:res;  // reverse the signal if necessary (return -1 instead of 1 an
//--- return a trading signal value
   return (res);
  }
//+------------------------------------------------------------------+
//|  Return 'true' when a new bar appears                            |
//+------------------------------------------------------------------+
bool isNewBar(const bool print_log=true)
  {
   static datetime bartime=0; // store open time of the current bar
//--- get open time of the zero bar
   datetime currbar_time=iTime(_Symbol,_Period,0);
//--- if open time changes, a new bar has arrived
   if(bartime!=currbar_time)
     {
      bartime=currbar_time;
      lastbar_timeopen=bartime;
      //--- display data on open time of a new bar in the log      
      if(print_log && !(MQLInfoInteger(MQL_OPTIMIZATION)||MQLInfoInteger(MQL_TESTER)))
        {
         //--- display a message with a new bar open time
         PrintFormat("%s: new bar on %s %s opened at %s",__FUNCTION__,_Symbol,
                     StringSubstr(EnumToString(_Period),7),
                     TimeToString(TimeCurrent(),TIME_SECONDS));
         //--- get data on the last tick
         MqlTick last_tick;
         if(!SymbolInfoTick(Symbol(),last_tick))
            Print("SymbolInfoTick() failed, error = ",GetLastError());
         //--- display the last tick time up to milliseconds
         PrintFormat("Last tick was at %s.%03d",
                     TimeToString(last_tick.time,TIME_SECONDS),last_tick.time_msc%1000
        }
      //--- we have a new bar
      return (true);
     }
//--- no new bar
   return (false);
  }
//+------------------------------------------------------------------+
//| Buy at a market price with a specified volume                    |
//+------------------------------------------------------------------+
bool Buy(double volume,ulong deviation=10,ulong  magicnumber=0)
  {
//--- buy at a market price


--- Page 1902 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1902
   return (MarketOrder(ORDER_TYPE_BUY,volume,deviation,magicnumber));
  }
//+------------------------------------------------------------------+
//| Sell at a market price with a specified volume                   |
//+------------------------------------------------------------------+
bool Sell(double volume,ulong deviation=10,ulong  magicnumber=0)
  {
//--- sell at a market price
   return (MarketOrder(ORDER_TYPE_SELL,volume,deviation,magicnumber));
  }
//+------------------------------------------------------------------+
//| Close positions by hold time in bars                             |
//+------------------------------------------------------------------+
void ClosePositionsByBars(int holdtimebars,ulong deviation=10,ulong  magicnumber=0)
  {
   int total=PositionsTotal(); // number of open positions   
//--- iterate over open positions
   for(int i=total-1; i>=0; i--)
     {
      //--- position parameters
      ulong  position_ticket=PositionGetTicket(i);                                    
      string position_symbol=PositionGetString(POSITION_SYMBOL);                      
      ulong  magic=PositionGetInteger(POSITION_MAGIC);                                
      datetime position_open=(datetime)PositionGetInteger(POSITION_TIME);             
      int bars=iBarShift(_Symbol,PERIOD_CURRENT,position_open)+1;                     
      //--- if a position's lifetime is already large, while MagicNumber and a symbol 
      if(bars>holdtimebars && magic==magicnumber && position_symbol==_Symbol)
        {
         int    digits=(int)SymbolInfoInteger(position_symbol,SYMBOL_DIGITS);         
         double volume=PositionGetDouble(POSITION_VOLUME);                            
         ENUM_POSITION_TYPE type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE)
         string str_type=StringSubstr(EnumToString(type),14);
         StringToLower(str_type); // lower the text case for correct message formattin
         PrintFormat("Close position #%I64u %s %s %.2f",
                     position_ticket,position_symbol,str_type,volume);
         //--- set an order type and sending a trade request
         if(type==POSITION_TYPE_BUY)
            MarketOrder(ORDER_TYPE_SELL,volume,deviation,magicnumber,position_ticket);
         else
            MarketOrder(ORDER_TYPE_BUY,volume,deviation,magicnumber,position_ticket);
        }
     }
  }
//+------------------------------------------------------------------+
//| Prepare and send a trade request                                 |
//+------------------------------------------------------------------+
bool MarketOrder(ENUM_ORDER_TYPE type,double volume,ulong slip,ulong magicnumber,ulong
  {


--- Page 1903 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1903
//--- declaring and initializing structures
   MqlTradeRequest request={};
   MqlTradeResult  result={};
   double price=SymbolInfoDouble(Symbol(),SYMBOL_BID);
   if(type==ORDER_TYPE_BUY)
      price=SymbolInfoDouble(Symbol(),SYMBOL_ASK);
//--- request parameters
   request.action   =TRADE_ACTION_DEAL;                     // trading operation type
   request.position =pos_ticket;                            // position ticket if clos
   request.symbol   =Symbol();                              // symbol
   request.volume   =volume;                                // volume 
   request.type     =type;                                  // order type
   request.price    =price;                                 // trade price
   request.deviation=slip;                                  // allowable deviation fro
   request.magic    =magicnumber;                           // order MagicNumber
//--- send a request
   if(!OrderSend(request,result))
     {
      //--- display data on failure
      PrintFormat("OrderSend %s %s %.2f at %.5f error %d",
                  request.symbol,EnumToString(type),volume,request.price,GetLastError
      return (false);
     }
//--- inform of a successful operation
   PrintFormat("retcode=%u  deal=%I64u  order=%I64u",result.retcode,result.deal,result
   return (true);
  }
See also
Event handling functions, Program running, Client terminal events, OnTimer, OnBookEvent,
OnChartEvent


--- Page 1904 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1904
OnCalculate
The function is called in the indicators when the Calculate event occurs for processing price data
changes. There are two function types. Only one of them can be used within a single indicator.
Calculation based on data array
int  OnCalculate(
   const int        rates_total,       // price[] array size
   const int        prev_calculated,   // number of handled bars at the previous call
   const int        begin,             // index number in the price[] array meaningful
   const double&    price[]            // array of values for calculation
   );
Calculations based on the current timeframe timeseries
int  OnCalculate(
   const int        rates_total,       // size of input time series
   const int        prev_calculated,   // number of handled bars at the previous call
   const datetime&  time[],            // Time array
   const double&    open[],            // Open array
   const double&    high[],            // High array
   const double&    low[],             // Low array
   const double&    close[],           // Close array
   const long&      tick_volume[],     // Tick Volume array
   const long&      volume[],          // Real Volume array
   const int&       spread[]           // Spread array
   );
Parameters
rates_total
[in]  Size of the price[] array or input series available to the indicator for calculation. In the second
function type, the parameter value corresponds to the number of bars on the chart it is launched
at.
prev_calculated
[in] Contains the value returned by the OnCalculate() function during the previous call. It is
designed to skip the bars that have not changed since the previous launch of this function.
begin
[in]  Index value in the price[] array meaningful data starts from. It allows you to skip missing or
initial data, for which there are no correct values.
price[]
[in]  Array of values for calculations. One of the price timeseries or a calculated indicator buffer
can be passed as the price[] array. Type of data passed for calculation can be defined using the
_AppliedTo predefined variable.
time{}
[in]  Array with bar open time values.


--- Page 1905 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1905
open[]
[in]  Array with Open price values.
high[]
[in]  Array with High price values.
low[]
[in]  Array with Low price values.
close[]
[in]  Array with Close price values.
tick_volume[]
[in]  Array with tick volume values.
volume[]
[in]  Array with trade volume values.
spread[]
[in]  Array with spread values for bars.
Return Value
int type value to be passed as the prev_calculated parameter during the next function call.
Note
If the OnCalculate() function is equal to zero, no indicator values are shown in the DataWindow of
the client terminal.
If the price data have been changed since the last call of the OnCalculate() function (a deeper
history has been loaded or gaps in the history have been filled), the value of the prev_calculated
input parameter is set to zero by the terminal itself.
To define the indexing direction in the time[], open[], high[], low[], close[], tick_volume[],
volume[] and spread[] arrays, call the ArrayGetAsSeries() function. In order not to depend on
defaults, call the ArraySetAsSeries() function for the arrays to work with.
When using the first function type, a necessary timeseries or indicator is selected by a user as the
price[] array in the Parameters tab when launching the indicator. To do this, specify the necessary
element in the drop-down list of the "Apply to" field.
To get custom indicator values from other mql5 programs, the iCustom() function is used. It returns
the indicator handle for subsequent operations. It is also possible to specify the required price []
array or the handle of another indicator. This parameter should be passed the last in the list of input
variables of a custom indicator.
It is necessary to use the connection between the value returned by the OnCalculate() function and
the prev_calculated second input parameter. When calling the function, the prev_calculated
parameter contains the value returned by the OnCalculate() function during the previous call. This
makes it possible to implement resource-saving algorithms for calculating a custom indicator in
order to avoid repetitive calculations for the bars that have not changed since the previous launch of
this function. 


--- Page 1906 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1906
Sample indicator
//+------------------------------------------------------------------+
//|                                           OnCalculate_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2000-2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property description "Sample Momentum indicator calculation"
//---- indicator settings
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_type1   DRAW_LINE
#property indicator_color1  Blue
//---- inputs
input int MomentumPeriod=14; // Calculation period
//---- indicator buffer
double    MomentumBuffer[];
//--- global variable for storing calculation period
int       IntPeriod;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
void OnInit()
  {
//--- check the input parameter
   if(MomentumPeriod<0)
     {
      IntPeriod=14;
      Print("Period parameter has an incorrect value. The following value is to be use
     }
   else
      IntPeriod=MomentumPeriod;
//---- buffers  
   SetIndexBuffer(0,MomentumBuffer,INDICATOR_DATA);
//---- indicator name to be displayed in DataWindow and subwindow
   IndicatorSetString(INDICATOR_SHORTNAME,"Momentum"+"("+string(IntPeriod)+")");
//--- set index of the bar the drawing starts from
   PlotIndexSetInteger(0,PLOT_DRAW_BEGIN,IntPeriod-1);
//--- set 0.0 as an empty value that is not drawn
   PlotIndexSetDouble(0,PLOT_EMPTY_VALUE,0.0);
//--- indicator accuracy to be displayed
   IndicatorSetInteger(INDICATOR_DIGITS,2);
  }
//+------------------------------------------------------------------+


--- Page 1907 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1907
//|  Momentum indicator calculation                                  |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,     // price[] array size 
                const int prev_calculated, // number of previously handled bars
                const int begin,           // where significant data start from 
                const double &price[])     // value array for handling
  {
//--- initial position for calculations
   int StartCalcPosition=(IntPeriod-1)+begin;
//---- if calculation data is insufficient
   if(rates_total<StartCalcPosition)
      return(0);  // exit with a zero value - the indicator is not calculated
//--- correct draw begin
   if(begin>0)
      PlotIndexSetInteger(0,PLOT_DRAW_BEGIN,StartCalcPosition+(IntPeriod-1));
//--- start calculations, define the starting position
   int pos=prev_calculated-1;
   if(pos<StartCalcPosition)
      pos=begin+IntPeriod;
//--- main calculation loop
   for(int i=pos;i<rates_total && !IsStopped();i++)
      MomentumBuffer[i]=price[i]*100/price[i-IntPeriod];
//--- OnCalculate execution is complete. Return the new prev_calculated value for the 
   return(rates_total);
  }
See also
ArrayGetAsSeries, ArraySetAsSeries, iCustom, Event handling functions, Program running, Client
terminal events, Access to timeseries and indicators


--- Page 1908 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1908
OnTimer
The function is called in EAs during the Timer event generated by the terminal at fixed time intervals.
void  OnTimer(void);
Return Value
No return value
Note
The Timer event is periodically generated by the client terminal for an EA, which activated the timer
using the EventSetTimer() function. Usually, this function is called in the OnInit() function. When
the EA stops working, the timer should be eliminated using EventKillTimer(), which is usually called
in the OnDeinit() function.
Each Expert Advisor and each indicator work with its own timer receiving events solely from this
timer. During mql5 application shutdown, the timer is forcibly destroyed in case it has been created
but has not been disabled by EventKillTimer() function.
If you need to receive timer events more frequently than once per 
second, 
use
EventSetMillisecondTimer() for creating a high-resolution timer. 
In general, when the timer period is reduced, the testing time is increased, as the handler of timer
events is called more often. When working in real-time mode, timer events are generated no more
than 1 time in 10-16 milliseconds due to hardware limitations.
Only one timer can be launched for each program. Each mql5 application and chart have their own
queue of events where all newly arrived events are placed. If the queue already contains Timer
event or this event is in the processing stage, then the new Timer event is not added to mql5
application queue. 
Sample EA with the OnTimer() handler
//+------------------------------------------------------------------+
//|                                               OnTimer_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2000-2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property description "Example of using the timer for calculating the trading server t
#property description "It is recommended to run the EA at the end of a trading week be
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create a timer with a 1 second period
   EventSetTimer(1);


--- Page 1909 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1909
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy the timer after completing the work
   EventKillTimer();
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//--- time of the OnTimer() first call
   static datetime start_time=TimeCurrent();
//--- trade server time during the first OnTimer() call
   static datetime start_tradeserver_time=0;
//--- calculated trade server time
   static datetime calculated_server_time=0;
//--- local PC time
   datetime local_time=TimeLocal();
//--- current estimated trade server time
   datetime trade_server_time=TimeTradeServer();
//--- if a server time is unknown for some reason, exit ahead of time
   if(trade_server_time==0)
      return;
//--- if the initial trade server value is not set yet
   if(start_tradeserver_time==0)
     {
      start_tradeserver_time=trade_server_time;
      //--- set a calculated value of a trade server      
      Print(trade_server_time);
      calculated_server_time=trade_server_time;
     }
   else
     {
      //--- increase time of the OnTimer() first call


--- Page 1910 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1910
      if(start_tradeserver_time!=0)
         calculated_server_time=calculated_server_time+1;;
     }
//--- 
   string com=StringFormat("                  Start time: %s\r\n",TimeToString(start_t
   com=com+StringFormat("                  Local time: %s\r\n",TimeToString(local_time
   com=com+StringFormat("TimeTradeServer time: %s\r\n",TimeToString(trade_server_time,
   com=com+StringFormat(" EstimatedServer time: %s\r\n",TimeToString(calculated_server
//--- display values of all counters on the chart
   Comment(com);
  }
See also
EventSetTimer, EventSetMillisecondTimer, EventKillTimer, GetTickCount, GetMicrosecondCount,
Client terminal events


--- Page 1911 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1911
OnTrade
The function is called in EAs when the Trade event occurs. The function is meant for processing
changes in order, position and trade lists.
void  OnTrade(void);
Return Value
No return value
Note
OnTrade() is called only for Expert Advisors. It is not used in indicators and scripts even if you add
there a function with the same name and type.
For any trade action (placing a pending order, opening/closing a position, placing stops, activating
pending orders, etc.), the history of orders and trades and/or the list of positions and current orders
is changed appropriately.
When handling an order, a trade server sends the terminal a message about the incoming Trade
event. To retrieve relevant data on orders and trades from history, it is necessary to perform a
trading history request using HistorySelect() first.
The trade events are generated by the server in case of:
· changing active orders,
· changing positions,
· changing deals,
· changing trade history.
Each  Trade event may appear as a result of one or several trade requests. Trade requests are sent
to the server using OrderSend() or OrderSendAsync(). Each request can lead to several trade events.
You cannot rely on the statement "One request - one Trade event", since the processing of events
may be performed in several stages, and each operation may change the state of orders, positions
and the trade history.
OnTrade() handler is called after the appropriate OnTradeTransaction() calls. In general, there is no
exact correlation in the number of OnTrade () and OnTradeTransaction () calls. One OnTrade() call
corresponds to one or several OnTradeTransaction calls.
Sample EA with OnTrade() handler
//+------------------------------------------------------------------+
//|                                               OnTrade_Sample.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2000-2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
input    int days=7;            // depth of trade history in days


--- Page 1912 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1912
//--- set the limits of the trade history on the global scope
datetime     start;             // start date for trade history in cache
datetime     end;               // end date for trade history in cache
//--- global counters
int          orders;            // number of active orders
int          positions;         // number of open positions
int          deals;             // number of deals in the trade history cache
int          history_orders;    // number of orders in the trade history cache
bool         started=false;     // flag of counter relevance
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   end=TimeCurrent();
   start=end-days*PeriodSeconds(PERIOD_D1);
   PrintFormat("Limits of the history to be loaded: start - %s, end - %s",
               TimeToString(start),TimeToString(end));
   InitCounters();
//---
   return(0);
  }
//+------------------------------------------------------------------+
//|  initialization of position, order and trade counters            |
//+------------------------------------------------------------------+
void InitCounters()
  {
   ResetLastError();
//--- load history
   bool selected=HistorySelect(start,end);
   if(!selected)
     {
      PrintFormat("%s. Failed to load history from %s to %s to cache. Error code: %d",
                  __FUNCTION__,TimeToString(start),TimeToString(end),GetLastError());
      return;
     }
//--- get the current value
   orders=OrdersTotal();
   positions=PositionsTotal();
   deals=HistoryDealsTotal();
   history_orders=HistoryOrdersTotal();
   started=true;
   Print("Counters of orders, positions and deals successfully initialized");
  }  
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+


--- Page 1913 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1913
void OnTick()
  {
   if(started) SimpleTradeProcessor();
   else InitCounters();
  }
//+------------------------------------------------------------------+
//| called when a Trade event arrives                                |
//+------------------------------------------------------------------+
void OnTrade()
  {
   if(started) SimpleTradeProcessor();
   else InitCounters();
  }
//+------------------------------------------------------------------+
//| example of processing changes in trade and history               |
//+------------------------------------------------------------------+
void SimpleTradeProcessor()
  {
   end=TimeCurrent();
   ResetLastError();
//--- download trading history from the specified interval to the program cache
   bool selected=HistorySelect(start,end);
   if(!selected)
     {
      PrintFormat("%s. Failed to load history from %s to %s to cache. Error code: %d",
                  __FUNCTION__,TimeToString(start),TimeToString(end),GetLastError());
      return;
     }
//--- get the current values
   int curr_orders=OrdersTotal();
   int curr_positions=PositionsTotal();
   int curr_deals=HistoryDealsTotal();
   int curr_history_orders=HistoryOrdersTotal();
//--- check if the number of active orders has been changed
   if(curr_orders!=orders)
     {
      //--- number of active orders has been changed
      PrintFormat("Number of orders has been changed. Previous value is %d, current va
                  orders,curr_orders);
      //--- update the value
      orders=curr_orders;
     }
//--- changes in the number of open positions
   if(curr_positions!=positions)
     {
      //--- number of open positions has been changed
      PrintFormat("Number of positions has been changed. Previous value is %d, current
                  positions,curr_positions);
      //--- update the value


--- Page 1914 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1914
      positions=curr_positions;
     }
//--- changes in the number of deals in the trade history cache
   if(curr_deals!=deals)
     {
      //--- number of deals in the trade history cache has been changed
      PrintFormat("Number of deals has been changed. Previous value is %d, current val
                  deals,curr_deals);
      //--- update the value
      deals=curr_deals;
     }
//--- changes in the number of history orders in the trade history cache
   if(curr_history_orders!=history_orders)
     {
      //--- number of history orders in the trade history cache has been changed
      PrintFormat("Number of orders in history has been changed. Previous value is %d,
                  history_orders,curr_history_orders);
     //--- update the value
     history_orders=curr_history_orders;
     }
//--- checking if it is necessary to change the limits of the trade history to be requ
   CheckStartDateInTradeHistory();
  }
//+------------------------------------------------------------------+
//|  changing the start date for requesting the trade history        |
//+------------------------------------------------------------------+
void CheckStartDateInTradeHistory()
  {
//--- initial interval, if we were to start working right now
   datetime curr_start=TimeCurrent()-days*PeriodSeconds(PERIOD_D1);
//--- make sure that the start limit of the trade history has not gone
//--- more than 1 day over the intended date
   if(curr_start-start>PeriodSeconds(PERIOD_D1))
     {
      //--- correct the start date of history to be loaded in the cache
      start=curr_start;
      PrintFormat("New start limit of the trade history to be loaded: start => %s",
                  TimeToString(start));
      //--- now reload the trade history for the updated interval
      HistorySelect(start,end);
      //--- correct the deal and order counters in history for further comparison
      history_orders=HistoryOrdersTotal();
      deals=HistoryDealsTotal();
     }
  }
//+------------------------------------------------------------------+
/* Sample output:
  Limits of the history to be loaded: start - 2018.07.16 18:11, end - 2018.07.23 18:11
  The counters of orders, positions and deals are successfully initialized


--- Page 1915 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1915
  Number of orders has been changed. Previous value 0, current value 1
  Number of orders has been changed. Previous value 1, current value 0
  Number of positions has been changed. Previous value 0, current value 1
  Number of deals has been changed. Previous value 0, current value 1
  Number of orders in the history has been changed. Previous value 0, current value 1
*/
See also
OrderSend, OrderSendAsync, OnTradeTransaction,  Client terminal events


--- Page 1916 ---
Event Handling
© 2000-2025, MetaQuotes Ltd.
1916
OnTradeTransaction
The function is called in EAs when the TradeTransaction event occurs. The function is meant for
handling trade request execution results.
void  OnTradeTransaction()
   const MqlTradeTransaction&    trans,     // trade transaction structure
   const MqlTradeRequest&        request,   // request structure
   const MqlTradeResult&         result     // response structure
   );
Parameters
trans
[in]  MqlTradeTransaction type variable describing a transaction made on a trading account.
request
[in]  MqlTradeRequest type variable describing a trade request that led to a transaction. It
contains the values for TRADE_TRANSACTION_REQUEST type transaction only.
result
[in]  MqlTradeResult type variable containing an execution result of a trade request that led to a
transaction. It contains the values for TRADE_TRANSACTION_REQUEST type transaction only.
Return Value
No return value
Note
OnTradeTransaction() is called to handle the TradeTransaction event sent by the trade server to the
terminal in the following cases:
· sending a trade request from an MQL5 program using the OrderSend()/OrderSendAsync()
functions and its subsequent execution;
· sending a trade request manually via the GUI and its subsequent execution;
· activations of pending and stop orders on the server;
· performing operations on the trade server side.
Data on transaction type is contained in the type field of the trans variable. Types of trade
transactions are described in the ENUM_TRADE_TRANSACTION_TYPE enumeration:
· TRADE_TRANSACTION_ORDER_ADD – adding a new active order
· TRADE_TRANSACTION_ORDER_UPDATE – changing an existing order
· TRADE_TRANSACTION_ORDER_DELETE – deleting an order from the list of active ones
· TRADE_TRANSACTION_DEAL_ADD – adding a deal to history
· TRADE_TRANSACTION_DEAL_UPDATE – changing a deal in history
· TRADE_TRANSACTION_DEAL_DELETE – deleting a deal from history
· TRADE_TRANSACTION_HISTORY_ADD – adding an order to history as a result of execution or
cancelation
· TRADE_TRANSACTION_HISTORY_UPDATE – changing an order in the order history
· TRADE_TRANSACTION_HISTORY_DELETE – deleting an order from the order history
· TRADE_TRANSACTION_POSITION – position change not related to a trade execution
