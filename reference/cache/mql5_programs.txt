=== MQL5 programs (Pages 1033-1088) ===

--- Page 1033 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1033
MQL5 Programs
For the mql5-program to operate, it must be compiled (Compile button or F7 key). Compilation should
pass without errors (some warnings are possible; they should be analyzed). At this process, an
executable file with the same name and with EX5 extension must be created in the corresponding
directory, terminal_dir\MQL5\Experts, terminal_dir\MQL5\indicators or terminal_dir\MQL5\scripts.
This file can be run.
Operating features of MQL5 programs are described in the following sections:
· Program running – order of calling predefined event-handlers.
· Testing trading strategies – operating features of MQL5 programs in the Strategy Tester.
· Client terminal events – description of events, which can be processed in programs.
· Call of imported functions – description order, allowed parameters, search details and call agreement
for imported functions.
· Runtime errors – getting information about runtime and critical errors.
Expert Advisors, custom indicators and scripts are attached to one of opened charts by Drag'n'Drop
method from the Navigator window.
For an expert Advisor to stop operating, it should be removed from a chart. To do it select "Expert
list" in chart context menu, then select an Expert Advisor from list and click "Remove" button.
Operation of Expert Advisors is also affected by the state of the "AutoTrading" button.
In order to stop a custom indicator, it should be removed from a chart.
Custom indicators and Expert Advisors work until they are explicitly removed from a chart;
information about attached Expert Advisors and Indicators is saved between client terminal sessions.
Scripts are executed once and are deleted automatically upon operation completion or change of the
current chart state, or upon client terminal shutdown. After the restart of the client terminal scripts
are not started, because the information about them is not saved.
Maximum one Expert Advisor, one script and unlimited number of indicators can operate in one chart.
Services do not require to be bound to a chart to work and are designed to perform auxiliary functions.
For example, in a service, you can create a custom symbol, open its chart, receive data for it in an
endless loop using the network functions and constantly update it. 


--- Page 1034 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1034
Program Running
Each script, each service and each Expert Advisor runs in its own separate thread. All indicators
calculated on one symbol, even if they are attached to different charts, work in the same thread.
Thus, all indicators on one symbol share the resources of one thread.
All other actions associated with a symbol, like processing of ticks and history synchronization, are
also consistently performed in the same thread with indicators. This means that if an infinite action is
performed in an indicator, all other events associated with its symbol will never be performed.
When running an Expert Advisor, make sure that it has an actual trading environment and can access
the history of the required symbol and period, and synchronize data between the terminal and the
server. For all these procedures, the terminal provides a start delay of no more than 5 seconds, after
which the Expert Advisor will be started with available data. Therefore, in case there is no connection
to the server, this may lead to a delay in the start of an Expert Advisor.
The below table contains a brief summary of MQL5 programs:
Program
Running
Note
Service
A separate thread, the number of
threads for services is equal to
the number of services
A looped service cannot break
running of other programs
Script
A separate thread, the number of
threads for scripts is equal to the
number of scripts
A looped script cannot break
running of other programs
Expert Advisor
A separate thread, the number of
threads for Expert Advisors is
equal to the number of Expert
Advisors
A looped Expert Advisor cannot
break running of other programs
Indicator
One thread for all indicators on a
symbol. The number of threads is
equal to the number of symbols
with indicators
An infinite loop in one indicator
will stop all other indicators on
this symbol
Right after a program is attached to a chart, it is uploaded to the client terminal memory, as well as
global variable are initialized. If some global variable of the class type has a constructor, this
constructor will be called during initialization of global variables.
After that the program is waiting for an event from the client terminal. Each mql5-program should
have at least one event-handler, otherwise the loaded program will not be executed. Event handlers
have  predefined names, parameters and return types.
Type
Function name
Parameters
Application
Comment
int
OnInit
none
Expert Advisors
and indicators
Init event handler. It
allows to use the void
return type.


--- Page 1035 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1035
Type
Function name
Parameters
Application
Comment
void
OnDeinit
const int reason
Expert Advisors
and indicators
Deinit event handler.
void
OnStart
none
scripts 
and
services
Start event handler.
int
OnCalculate
const int rates_total,
const 
int
prev_calculated,
const datetime &Time[],
const double &Open[],
const double &High[],
const double &Low[],
const double &Close[],
const 
long
&TickVolume[],
const long &Volume[],
const int &Spread[]
indicators
Calculate 
event
handler for all prices.
int
OnCalculate
const int rates_total,
const 
int
prev_calculated,
const int begin,
const double &price[]
indicators
Calculate 
event
handler on the single
data array. 
Indicator cannot have
two event handlers
simultaneously.
In this case the only
one event handler will
work on the data
array.
void
OnTick
none
Expert Advisors
NewTick 
event
handler. While the
event of a new tick
receipt 
is 
being
processed, no other
events of this type
are received.
void
OnTimer
none
Expert Advisors
and indicators
Timer event handler.
void
OnTrade
none
Expert Advisors
Trade event handler.
double
OnTester
none
Expert Advisors
Tester event handler.
void
OnChartEvent
const int id,
const long &lparam,
const double &dparam,
const string &sparam
Expert Advisors
and indicators
ChartEvent 
event
handler.
void
OnBookEvent
const 
string
&symbol_name
Expert Advisors
and indicators
BookEvent 
event
handler.


--- Page 1036 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1036
A client terminal sends new events to the corresponding open charts. Events can also be generated by
charts (chart events) or mql5-programs (custom events). Generation of events of creation or deletion
of graphical objects on a chart can be enabled or disabled by setting CHART_EVENT_OBJECT_CREATE
and CHART_EVENT_OBJECT_DELETE chart properties. Each MQL5 program and each chart has its own
queue of events, where all new incoming events are added.
A program receives only events from the chart it runs on. All events are processed one after another in
the order they are received. If a queue already has a NewTick event, or this event is currently being
processed, then the new NewTick event is not placed in the queue of the MQL5 program. Similarly, if
ChartEvent is already enqueued, or this event is being processed, no new event of this kind is
enqueued. The timer events are handled the same way – if the Timer event is in the queue or being
handled, the new timer event is not enqueued.
Event queues have a limited but sufficient size, so that the queue overflow for well written programs
is unlikely. In case of queue overflow, new events are discarded without queuing.
It is strongly recommended not to use infinite loops to handle events. Possible exceptions are scripts
and services handling a single Start event.
Libraries do not handle any events.
Functions prohibited in Indicators and Expert Advisors
Indicators, scripts and Expert Advisors are executable programs written in MQL5. They are designed
for different types of tasks. Therefore there are some restrictions on the use of certain functions,
depending on the type of program. The following functions are prohibited in indicators:
· OrderCalcMargin();
· OrderCalcProfit();
· OrderCheck();
· OrderSend();
· SendFTP();
· Sleep();
· ExpertRemove();
· MessageBox().
All functions designed for indicators are prohibited in Expert Advisors and scripts:
· SetIndexBuffer();
· IndicatorSetDouble();
· IndicatorSetInteger();
· IndicatorSetString();
· PlotIndexSetDouble();
· PlotIndexSetInteger();
· PlotIndexSetString();


--- Page 1037 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1037
· PlotIndexGetInteger.
The library is not an independent program and is executed in the context of the MQL5 program that
has called it: script, indicator or Expert Advisor. Accordingly, the above restrictions apply to the called
library.
Functions prohibited in services
Services do not accept any events, as they are not bound to a chart.  The following functions are
prohibited in services:
ExpertRemove();
EventSetMillisecondTimer();
EventSetTimer();
EventKillTimer();
SetIndexBuffer();
IndicatorSetDouble();
IndicatorSetInteger();
IndicatorSetString();
PlotIndexSetDouble();
PlotIndexSetInteger();
PlotIndexSetString();
PlotIndexGetInteger();
Loading and Unloading of Indicators
Indicators are loaded in the following cases:
· an indicator is attached to a chart;
· terminal start (if the indicator was attached to the chart prior to the shutdown of the terminal); 
· loading of a template (if the indicator attached to a chart is specified in the template); 
· change of a profile (if the indicator is attached to one of the profile charts); 
· change of a symbol and/or timeframe of a chart, to which the indicator is attached; 
· change of the account to which the terminal is connected;
· after the successful recompilation of an indicator (if the indicator was attached to a chart);
· change of input parameters of the indicator.
Indicators are unloaded in the following cases: 
· when detaching an indicator from a chart; 
· terminal shutdown (if the indicator was attached to a chart); 
· loading of a template (if an indicator is attached to a chart); 


--- Page 1038 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1038
· closing of a chart, to which the indicator was attached; 
· change of a profile (if the indicator is attached to one of charts of the changed profile); 
· change of a symbol and/or timeframe of a chart, to which the indicator is attached; 
· change of the account to which the terminal is connected;
· change of input parameters of the indicator.
Loading and Unloading of Expert Advisors
Expert Advisors are loaded in the following cases:
· when attaching an Expert Advisor to a chart;
· terminal start (if the Expert Advisor was attached to the chart prior to the shutdown of the
terminal);
· loading of a template (if the Expert Advisor attached to the chart is specified in the template);
· change of a profile (if the Expert Advisor is attached to the one of the profile charts);
· connection to an account, even if the account number is the same (if the Expert Advisor was
attached to the chart before the authorization of the terminal on the server).
Expert Advisors are unloaded in the following cases:
· when detaching an Expert Advisor from a chart;
· if a new Expert Advisor is attached to a chart, if another Expert Advisor has been attached already,
this Expert Advisor is unloaded.
· terminal shutdown (if the Expert Advisor was attached to a chart);
· loading of a template (if an Expert Advisor is attached to the chart);
· close of a chart, to which the Expert Advisor is attached.
· change of a profile (if the Expert Advisor is attached to one of charts of the changed profile);
· change of the account to which the terminal is connected (if the Expert Advisor was attached to the
chart before the authorization of the terminal on the server);
· calling the ExpertRemove() function.
In case the symbol or timeframe of a chart, to which the Expert Advisor is attached, changes,
Expert Advisors are not loaded or unloaded. In this case client terminal subsequently calls OnDeinit()
handlers on the old symbol/timeframe and OnInit() on the new symbol/timeframe (if they are such),
values of global variables and static variables are not reset. All events, which have been received for
the Expert Advisor before the initialization is completed (OnInit() function) are skipped.
Loading and Unloading of Scripts 
Scripts are loaded immediately after they are attached to a chart and unloaded immediately after they
complete their operation. OnInit() and OnDeinit() are not called for scripts.
When a program is unloaded (deleted from a chart) the client terminal performs deinitialization of
global variables and deletes the events queue. In this case deinitialization means reset of all the


--- Page 1039 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1039
string-type variables, deallocation of dynamical array objects and call of their destructors if they are
available.
Loading and Unloading services
Services are loaded right after starting the terminal if they were launched at the moment of the
terminal shutdown. Services are unloaded immediately after completing their work.
Services have a single OnStart() handler, in which you can implement an endless data receiving and
handling loop, for example creating and updating custom symbols using the network functions.
Unlike Expert Advisors, indicators and scripts, services are not bound to a specific chart, therefore a
separate mechanism is provided to launch them.  A new service instance is created in the Navigator
using the "Add Service" command. A service instance can be launched, stopped and removed using the
appropriate instance menu. To manage all instances, use the service menu.
For a better understanding of the Expert Advisor operation we recommend to compile the code of the
following Expert Advisor and perform actions of load/unload, template change, symbol change,
timeframe change etc:
Example:
//+------------------------------------------------------------------+
//|                                                   TestExpert.mq5 |
//|                        Copyright 2009, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "2009, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.00"
class CTestClass
  {
public:  
   CTestClass() { Print("CTestClass constructor"); }
   ~CTestClass() { Print("CTestClass destructor"); }
  };
CTestClass global;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   Print("Initialization");
//---
   return(INIT_SUCCEEDED);


--- Page 1040 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1040
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
   Print("Deinitialization with reason",reason);
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
  }
//+------------------------------------------------------------------+
See also
Client terminal events, Event handlers


--- Page 1041 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1041
Trade Permission
Trade Automation
MQL5 language provides a special group of trade functions designed for developing automated trading
systems. Programs developed for automated trading with no human intervention are called Expert
Advisors or trading robots. In order to create an Expert Advisor in MetaEditor, launch MQL5 Wizard
and select one of the two options:
· Expert Advisor (template) – allows you to create a template with ready-made event handling
functions that should be supplemented with all necessary functionality by means of programming.
· Expert Advisor (generate) – allows you to  develop a full-fledged trading robot simply by selecting the
necessary modules: trading signals module, money management module and trailing stop module.
Trading functions can work only in Expert Advisors and scripts. Trading is not allowed for indicators.
Checking for Permission to Perform Automated Trading
In order to develop a reliable Expert Advisor capable of working without human intervention, it is
necessary to arrange a set of important checks. First, we should programmatically check if trading is
allowed at all. This is a basic check that is indispensable when developing any automated system.
Checking for permission to perform automated trading in the terminal
The terminal settings provide you with an ability to allow or forbid automated trading for all programs.


--- Page 1042 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1042
You can switch automated trading option right on the terminal's Standard panel:  
·
– automated trading enabled, trading functions in launched applications are allowed
for use.
·
 – automated trading disabled, running applications are unable to execute trading
functions. 
Sample check:
if (!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) 
   Alert("Check if automated trading is allowed in the terminal settings!");
Checking if trading is allowed for a certain running Expert Advisor/script
You can allow or forbid automated trading for a certain program when launching it. To do this, use the
special check box in the program properties.


--- Page 1043 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1043
Sample check:
   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
      Alert("Check if automated trading is allowed in the terminal settings!");
   else
     {
      if(!MQLInfoInteger(MQL_TRADE_ALLOWED))
         Alert("Automated trading is forbidden in the program settings for ",__FILE__)
     }
Checking if trading is allowed for any Expert Advisors/scripts for the current
account
Automated trading can be disabled at the trade server side. Sample check:
   if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT))
      Alert("Automated trading is forbidden for the account ",AccountInfoInteger(ACCOU
      " at the trade server side");
If automated trading is disabled for a trading account, trading operations of Expert Advisors/scripts
are not executed.
Checking if trading is allowed for the current account
In some cases, any trading operations are disabled for a certain trading account – neither manual nor
automated trading can be performed. Sample check when an investor password has been used to
connect to a trading account:
   if(!AccountInfoInteger(ACCOUNT_TRADE_ALLOWED))
      Comment("Trading is forbidden for the account ",AccountInfoInteger(ACCOUNT_LOGIN
            ".\n Perhaps an investor password has been used to connect to the trading 
            "\n Check the terminal journal for the following entry:",


--- Page 1044 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1044
            "\n\'",AccountInfoInteger(ACCOUNT_LOGIN),"\': trading has been disabled - 
AccountInfoInteger(ACCOUNT_TRADE_ALLOWED) may return false in the following cases:
· no 
connection 
to 
the 
trade 
server. 
That 
can 
be 
checked 
using
TerminalInfoInteger(TERMINAL_CONNECTED);
· trading account switched to read-only mode (sent to the archive);
· trading on the account is disabled at the trade server side;
· connection to a trading account has been performed in Investor mode.
See also
Client Terminal Properties, Account Properties, Properties of a Running MQL5 Program


--- Page 1045 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1045
Client Terminal Events
Init
Immediately after the client terminal loads a program (an Expert Advisor or custom indicator) and
starts the process of initialization of global variables, the Init event will be sent, which will be
processed by OnInit() event handler, if there is such. This event is also generated after a financial
instrument and/or chart timeframe is changed, after a program is recompiled in MetaEditor, after
input parameters are changed from the setup window of an Expert Advisor or a custom indicator. An
Expert Advisor is also initialized after the account is changed. The Init event is not generated for
scripts.
Deinit
Before global variables are deinitialized and the program (Expert Advisor or custom indicator) is
unloaded, the client terminal sends the Deinit event to the program. Deinit is also generated when the
client terminal is closed, when a chart is closed, right before the security and/or timeframe is
changed, at a successful program re-compilation, when input parameters are changed, and when
account is changed.
The deinitialization reason can be obtained from the parameter, passed to the OnDeinit() function.
The OnDeinit() function run is restricted to 2.5 seconds. If during this time the function hasn't been
completed, then it is forcibly terminated. The Deinit event is not generated for scripts.
Start
Start is a special event for launching a script or a service after loading it. It is handled by the OnStart
function. The Start event is not passed to EAs and custom indicators.
NewTick
The NewTick event is generated if there are new quotes, it is processed by OnTick() of Expert
Advisors attached. In case when OnTick function for the previous quote is being processed when a new
quote is received, the new quote will be ignored by an Expert Advisor, because the corresponding
event will not enqueued.
All new quotes that are received while the program is running are ignored until the OnTick() is
completed. After that the function will run only after a new quote is received. The NewTick event is
generated irrespective of whether automated trade is allowed or not ("Allow/prohibit Auto trading"
button). The prohibition of automated trading denotes only that sending of trade requests from an
Expert Advisor is not allowed, while the Expert Advisor keeps working.
The prohibition of automated trading by pressing the appropriate button will not stop the current
execution of the OnTick() function.
Calculate
The Calculate event is generated only for indicators right after the Init event is sent and at any change
of price data. It is processed by the OnCalculate function.


--- Page 1046 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1046
Timer
The Timer event is periodically generated by the client terminal for the Expert Advisor that has
activated the timer by the EventSetTimer function. Usually, this function is called by OnInit. Timer
event processing is performed by the OnTimer function. After the operation of the Expert Advisor is
completed, it is necessary to destroy the timer using the EventKillTimer function, which is usually
called in the OnDeinit function.
Trade
The Trade event is generated when a trade operation is completed on a trade server. The Trade event
is handled by the OnTrade() function for the following trade operations:
· sending, modifying or removing of a pending order; 
· cancellation of a pending order with not enough of money or expiration; 
· activation of a pending order;
· opening, adding or closing a position (or part of the position); 
· modifying of the open position (change stops – Stop Loss and/or Take Profit).
TradeTransaction
When performing some definite actions on a trade account, its state changes. Such actions include:
· Sending a trade request from any MQL5 application in the client terminal using OrderSend and
OrderSendAsync functions and its further execution;
· Sending a trade request via the terminal graphical interface and its further execution;
· Pending orders and stop orders activation on the server;
· Performing operations on a trade server side.
The following trade transactions are performed as a result of these actions:
· handling a trade request;
· changing open orders;
· changing orders history;
· changing deals history;
· changing positions.
For example, when sending a market buy order, it is handled, an appropriate buy order is created for
the account, the order is then executed and removed from the list of the open ones, then it is added
to the orders history, an appropriate deal is added to the history and a new position is created. All
these actions are trade transactions. Arrival of such a transaction at the terminal is a
TradeTransaction event. This event is handled by OnTradeTransaction function.
Tester
The Tester event is generated after testing of an Expert Advisor on history data is over. The event is
handled by the OnTester() function.


--- Page 1047 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1047
TesterInit
The TesterInit event is generated with the start of optimization in the strategy tester before the first
optimization pass. The TesterInit event is handled by the OnTesterInit() function.
TesterPass
The TesterPass event is generated when a new data frame is received. The TesterPass event is
handled by the OnTesterPass() function.
TesterDeinit
The TesterDeinit event is generated after the end of optimization of an Expert Advisor in the strategy
tester. The TesterDeinit event is handled by the OnTesterDeinit() function.
ChartEvent
The ChartEvent event is generated by the client terminal when a user is working with a chart:
· keystroke, when the chart window is in focus;
· graphical object created
· graphical object deleted
· mouse press on the graphical object of the chart
· move of the graphical object using the mouse
· end of text editing in LabelEdit.
Also there is a custom event ChartEvent, which can be sent to an Expert Advisor by any mql5 program
by using the EventChartCustom function. The event is processed by the OnChartEvent function.
BookEvent
The BookEvent event is generated by the client terminal after the Depth Of Market is changed; it is
processed by the OnBookEvent function. To start generation of BookEvent for the specified symbol, it
is necessary to subscribe the symbol to this event by using the MarketBookAdd function.
To unsubscribe from BookEvent for a specified symbol, it is necessary to call the MarketBookRelease
function. The BookEvent event is a broadcasting-type event - it means that it is sufficient to subscribe
just one Expert Advisor for this event, and all other Expert Advisors that have the OnBookEvent event
handler, will receive it. That's why it is necessary to analyze the symbol name, which is passed to a
handler as a parameter.
See also
Event handlers, Program running


--- Page 1048 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1048
Resources
Using graphics and sound in MQL5 programs
Programs in MQL5 allow working with sound and graphic files:
· PlaySound() plays a sound file;
· ObjectCreate() allows creating user interfaces using graphical objects OBJ_BITMAP and
OBJ_BITMAP_LABEL. 
PlaySound()
Example of call of the PlaySound() function:
//+------------------------------------------------------------------+
//| Calls standard OrderSend() and plays a sound                     |
//+------------------------------------------------------------------+
void OrderSendWithAudio(MqlTradeRequest  &request, MqlTradeResult &result)
  {
  //--- send a request to a server
   OrderSend(request,result);
   //--- if a request is accepted, play sound Ok.wav 
   if(result.retcode==TRADE_RETCODE_PLACED) PlaySound("Ok.wav");
   //--- if fails, play alarm from file timeout.wav
   else PlaySound("timeout.wav");
  }
The example shows how to play sounds from files 'Ok.wav' and 'timeout.wav', which are included into
the standard terminal package. These files are located in the folder terminal_directory\Sounds. Here
terminal_directory is a folder, from which the MetaTrader 5 Client Terminal is started. The location
of the terminal directory can be found out from an mql5 program in the following way:
//--- Folder, in which terminal data are stored
   string terminal_path=TerminalInfoString(TERMINAL_PATH);
You can use sound files not only from the folder terminal_directory\Sounds, but also from any
subfolder located in terminal_data_directory\MQL5. You can find out the location of the terminal
data directory from the terminal menu "File" -> "Open Data Folder" or using program method:
//--- Folder, in which terminal data are stored
   string terminal_data_path=TerminalInfoString(TERMINAL_DATA_PATH);
For example, if the Demo.wav sound file is located in terminal_data_directory\MQL5\Files, then call of
PlaySound() should be written the following way:
//--- play Demo.wav from the folder terminal_directory_data\MQL5\Files\
   PlaySound("\\Files\\Demo.wav");
Please note that in the comment the path to the file is written using backslash "\", and in the function
"\\" is used.


--- Page 1049 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1049
When specifying the path, always use only the double backslash as a separator, because a single
backslash is a control symbol for the compiler when dealing with constant strings and character
constants in the program source code. 
Call PlaySound() function with NULL parameter to stop playback:
//--- call of PlaySound() with NULL parameter stops playback
   PlaySound(NULL);
ObjectCreate()
Example of an Expert Advisor, which creates a graphical label (OBJ_BITMAP_LABEL) using the
ObjectCreate() function.
string label_name="currency_label";        // name of the OBJ_BITMAP_LABEL object
string euro      ="\\Images\\euro.bmp";    // path to the file terminal_data_directory
string dollar    ="\\Images\\dollar.bmp";  // path to the file terminal_data_directory
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create a button OBJ_BITMAP_LABEL, if it hasn't been created yet
   if(ObjectFind(0,label_name)<0)
     {
      //--- trying to create object OBJ_BITMAP_LABEL
      bool created=ObjectCreate(0,label_name,OBJ_BITMAP_LABEL,0,0,0);
      if(created)
        {
         //--- link the button to the left upper corner of the chart
         ObjectSetInteger(0,label_name,OBJPROP_CORNER,CORNER_RIGHT_UPPER);
         //--- now set up the object properties
         ObjectSetInteger(0,label_name,OBJPROP_XDISTANCE,100);
         ObjectSetInteger(0,label_name,OBJPROP_YDISTANCE,50);
         //--- reset the code of the last error to 0
         ResetLastError();
         //--- download a picture to indicate the "Pressed" state of the button
         bool set=ObjectSetString(0,label_name,OBJPROP_BMPFILE,0,euro);
         //--- test the result
         if(!set)
           {
            PrintFormat("Failed to download image from file %s. Error code %d",euro,Ge
           }
         ResetLastError();
         //--- download a picture to indicate the "Unpressed" state of the button
         set=ObjectSetString(0,label_name,OBJPROP_BMPFILE,1,dollar);
         
         if(!set)


--- Page 1050 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1050
           {
            PrintFormat("Failed to download image from file %s. Error code %d",dollar,
           }
         //--- send a command for a chart to refresh so that the button appears immedi
         ChartRedraw(0);
        }
      else
        {
         //--- failed to create an object, notify
         PrintFormat("Failed to create object OBJ_BITMAP_LABEL. Error code %d",GetLast
        }
     }
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- delete an object from a chart 
   ObjectDelete(0,label_name);
  }
Creation and setup of the graphical object named currency_label are carried out in the OnInit()
function. The paths to the graphical files are set in global variables euro and dollar, a double backlash
is used for a separator:
string euro      ="\\Images\\euro.bmp";    // path to the file terminal_dara_directory
string dollar    ="\\Images\\dollar.bmp";  // path to the file terminal_dara_directory
The files are located in the folder terminal_data_directory\MQL5\Images.
Object OBJ_BITMAP_LABEL is actually a button, which displays one of the two images, depending on
the button state (pressed or unpressed): euro.bmp or dollar.bmp.


--- Page 1051 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1051
The size of the button with a graphical interface is automatically adjusted to the size of the picture.
The image is changed by a left mouse button click on the OBJ_BITMAP_LABEL object ("Disable
selection" option must be checked in the properties). The OBJ_BITMAP object is created the same
way - it is used for creating the background with a necessary image. 
The value of the OBJPROP_BMPFILE property, which is responsible for the appearance of the objects
OBJ_BITMAP and OBJ_BITMAP_LABEL, can be changed dynamically. This allows creating various
interactive user interfaces for mql5 programs.
Including resources to executable files during compilation of mql5
programs
An mql5 program may need a lot of different downloadable resources in the form of image and sound
files. In order to eliminate the need to transfer all these files when moving an executable file in MQL5,
the compiler's directive #resource should be used:
 #resource path_to_resource_file
The #resource command tells the compiler 
that 
the 
resource 
at 
the 
specified 
path
path_to_resource_file should be included into the executable EX5 file. Thus all the necessary images
and sounds can be located directly in an EX5 file, so that there is no need to transfer separately the
files used in it, if you want to run the program on a different terminal. Any EX5 file can contain
resources, and any EX5 program can use resources from another EX5 program.
The files in format BMP and WAV are automatically compressed before including them to an EX5 file.
This denotes that in addition to the creation of complete programs in MQL5, using resources also
allows to reduce the total size of necessary files when using graphics and sounds, as compared to the
usual way of MQL5 program writing.
The resource file size must not exceed 128 Mb.


--- Page 1052 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1052
Search for specified resources by a compiler
A resource is inserted using the command #resource "<path to the resource file>"
 #resource "<path_to_resource_file>"
The length of the constant string <path_to_resource_file> must not exceed 63 characters.
The compiler searches for a resource at the specified path in the following order:
· if the backslash "\" separator (written as "\\") is placed at  the beginning of the path, it searches for
the resource relative to the directory terminal_data_directory\MQL5\,
· if there is no backslash, it searches for the resource relative to the location of the source file, in
which the resource is written.
The resource path cannot contain the substrings "..\\" and ":\\".
Examples of resource inclusion:
//--- correct specification of resources
#resource "\\Images\\euro.bmp" // euro.bmp is located in terminal_data_directory\MQL5\
#resource "picture.bmp"        // picture.bmp is located in the same directory as the 
#resource "Resource\\map.bmp"  // the resource is located in source_file_directory\Res
//--- incorrect specification of resources
#resource ":picture_2.bmp"     // must not contain ":"
#resource "..\\picture_3.bmp"  // must not contain ".."
#resource "\\Files\\Images\\Folder_First\\My_panel\\Labels\\too_long_path.bmp" //more 
Use of Resources
Resource name 
After a resource is declared using the #resource directive, it can be used in any part of a program. The
name of the resource is its path without a backslash at the beginning of the line, which sets the path
to the resource. To use your own resource in the code, the special sign "::" should be added before the
resource name.
Examples:
//--- examples of resource specification and their names in comments
#resource "\\Images\\euro.bmp"          // resource name - Images\euro.bmp
#resource "picture.bmp"                 // resource name - picture.bmp
#resource "Resource\\map.bmp"           // resource name - Resource\map.bmp
#resource "\\Files\\Pictures\\good.bmp" // resource name - Files\Pictures\good.bmp
#resource "\\Files\\Demo.wav";          // resource name - Files\Demo.wav"
#resource "\\Sounds\\thrill.wav";       // resource name - Sounds\thrill.wav"
...                                  
//--- utilization of resources


--- Page 1053 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1053
ObjectSetString(0,bitmap_name,OBJPROP_BMPFILE,0,"::Images\\euro.bmp");
...
ObjectSetString(0,my_bitmap,OBJPROP_BMPFILE,0,"::picture.bmp");
...
set=ObjectSetString(0,bitmap_label,OBJPROP_BMPFILE,1,"::Files\\Pictures\\good.bmp");
...
PlaySound("::Files\\Demo.wav");
...
PlaySound("::Sounds\\thrill.wav");
It should be noted that when setting images from a resource to the OBJ_BITMAP and
OBJ_BITMAP_LABEL objects, the value of the OBJPROP_BMPFILE property cannot be modified
manually. For example, for creating OBJ_BITMAP_LABEL we use resources euro.bmp and dollar.bmp.
#resource "\\Images\\euro.bmp";    // euro.bmp is located in terminal_data_directory\M
#resource "\\Images\\dollar.bmp";  // dollar.bmp is located in terminal_data_directory
When viewing the properties of this object, we'll see that the properties BitMap File (On) and BitMap
File (Off) are dimmed and cannot be change manually:
Using the resources of other mql5 programs
There is another advantage of using resources – in any MQL5 program, resources of another EX5 file
can be used. Thus the resources from one EX5 file can be used in many other mql5 programs.
In 
order 
to 
use 
a 
resource 
name 
from 
another 
file, 
it 
should 
be 
specified 
as
<path_EX5_file_name>::<resource_name>. For example, suppose the Draw_Triangles_Script.mq5
script contains a resource to an image in the file triangle.bmp:
 #resource "\\Files\\triangle.bmp"
Then its name, for using in the script itself, will look like "Files\triangle.bmp", and in order to use it,
"::" should be added to the resource name.


--- Page 1054 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1054
//--- using the resource in the script
ObjectSetString(0,my_bitmap_name,OBJPROP_BMPFILE,0,"::Files\\triangle.bmp");
In order to use the same resource from another program, e.g. from an Expert Advisor, we need to add
to the resource name the path to the EX5 file relative to terminal_data_directory\MQL5\ and the
name of the script's EX5 file - Draw_Triangles_Script.ex5. Suppose the script is located in the
standard folder terminal_data_directory\MQL5\Scripts\, then the call should be written the following
way:
//--- using a resource from a script in an EA
ObjectSetString(0,my_bitmap_name,OBJPROP_BMPFILE,0,"\\Scripts\\Draw_Triangles_Script.e
If the path to the executable file is not specified when calling the resource from another EX5, the
executable file is searched for in the same folder that contains the program that calls the resource.
This means that if an Expert Advisor calls a resource from Draw_Triangles_Script.ex5 without
specification of the path, like this:
//--- call script resource in an EA without specifying the path
ObjectSetString(0,my_bitmap_name,OBJPROP_BMPFILE,0,"Draw_Triangles_Script.ex5::Files\\
then the file will be searched for in the folder terminal_data_directory\MQL5\Experts\, if the Expert
Advisor is located in terminal_data_directory\MQL5\Experts\.
Working with custom indicators included as resources
One or several custom indicators may be necessary for the operation of MQL5 applications. All of them
can be included into the code of an executable MQL5 program. Inclusion of indicators as resources
simplifies the distribution of applications.
Below is an example of including and using SampleIndicator.ex5 custom indicator located in
terminal_data_folder\MQL5\Indicators\ directory:
//+------------------------------------------------------------------+
//|                                                     SampleEA.mq5 |
//|                        Copyright 2013, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#resource "\\Indicators\\SampleIndicator.ex5"
int handle_ind;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   handle_ind=iCustom(_Symbol,_Period,"::Indicators\\SampleIndicator.ex5");
   if(handle_ind==INVALID_HANDLE)
     {
      Print("Expert: iCustom call: Error code=",GetLastError());
      return(INIT_FAILED);


--- Page 1055 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1055
     }
//--- ...
   return(INIT_SUCCEEDED);
  }
The case when a custom indicator in OnInit() function creates one or more copies of itself requires
special consideration. Please keep in mind that the resource should be specified in the following way:
<path_EX5_file_name>::<resource_name>.
For example, if SampleIndicator.ex5 indicator is included to SampleEA.ex5 Expert Advisor as a
resource, the path to itself specified when calling iCustom() in the custom indicator's initialization
function looks the following way: "\\Experts\\SampleEA.ex5::Indicators\\SampleIndicator.ex5". When
this path is set explicitly, SampleIndicator.ex5 custom indicator is rigidly connected to SampleEA.ex5
Expert Advisor losing ability to work independently.
The path to itself can be received using GetRelativeProgramPath() function. The example of its usage
is provided below:
//+------------------------------------------------------------------+
//|                                              SampleIndicator.mq5 |
//|                        Copyright 2013, MetaQuotes Software Corp. |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property indicator_separate_window
#property indicator_plots 0
int handle;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- the wrong way to provide a link to itself
//--- string path="\\Experts\\SampleEA.ex5::Indicators\\SampleIndicator.ex5";  
//--- the right way to receive a link to itself
  string path=GetRelativeProgramPath();
//--- indicator buffers mapping
   handle=iCustom(_Symbol,_Period,path,0,0);
   if(handle==INVALID_HANDLE)
     {
      Print("Indicator: iCustom call: Error code=",GetLastError());
      return(INIT_FAILED);
     }
   else Print("Indicator handle=",handle);
//---
   return(INIT_SUCCEEDED);
  }
///....
//+------------------------------------------------------------------+
//| GetRelativeProgramPath                                           |
//+------------------------------------------------------------------+


--- Page 1056 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1056
string GetRelativeProgramPath()
  {
   int pos2;
//--- get the absolute path to the application
   string path=MQLInfoString(MQL_PROGRAM_PATH);
//--- find the position of "\MQL5\" substring
   int    pos =StringFind(path,"\\MQL5\\");
//--- substring not found - error
   if(pos<0)
      return(NULL);
//--- skip "\MQL5" directory
   pos+=5;
//--- skip extra '\' symbols
   while(StringGetCharacter(path,pos+1)=='\\')
      pos++;
//--- if this is a resource, return the path relative to MQL5 directory
   if(StringFind(path,"::",pos)>=0)
      return(StringSubstr(path,pos));
//--- find a separator for the first MQL5 subdirectory (for example, MQL5\Indicators)
//--- if not found, return the path relative to MQL5 directory
   if((pos2=StringFind(path,"\\",pos+1))<0)
      return(StringSubstr(path,pos));
//--- return the path relative to the subdirectory (for example, MQL5\Indicators)
   return(StringSubstr(path,pos2+1));
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const int begin,        
                const double& price[])
  {
//--- return value of prev_calculated for next call
   return(rates_total);
  }
Resource variables
Resources can be declared using the resource variables and treated as if they are variables of the
appropriate type. Declaration format:
#resource path_to_the_resource_file as resource_variable_type resource_variable_name
Sample declarations:
#resource "data.bin" as int ExtData[]             // declare the numeric array contain


--- Page 1057 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1057
#resource "data.bin" as MqlRates ExtData[]        // declare the simple structures arr
//--- strings
#resource "data.txt" as string ExtCode            // declare the string containing the
//--- graphical resources
#resource "image.bmp" as bitmap ExtBitmap[]       // declare the one-dimensional array
#resource "image.bmp" as bitmap ExtBitmap2[][]    // declare the two-dimensional array
In case of such declaration, the resource data can be addressed only via the variable, auto addressing
via "::<rsource name>" does not work. 
#resource "\\Images\\euro.bmp" as bitmap euro[][]
#resource "\\Images\\dollar.bmp"
//+------------------------------------------------------------------+
//|  OBJ_BITMAP_LABEL object creation function using the resource   |
//+------------------------------------------------------------------+
void Image(string name,string rc,int x,int y)
  {
   ObjectCreate(0,name,OBJ_BITMAP_LABEL,0,0,0);
   ObjectSetInteger(0,name,OBJPROP_XDISTANCE,x);
   ObjectSetInteger(0,name,OBJPROP_YDISTANCE,y);
   ObjectSetString(0,name,OBJPROP_BMPFILE,rc);
  }
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
  {
//--- output the size of the image [width, height] stored in euro resource variable
   Print(ArrayRange(euro,1),", ",ArrayRange(euro,0));
//--- change the image in euro - draw the red horizontal stripe in the middle
   for(int x=0;x<ArrayRange(euro,1);x++)
      euro[ArrayRange(euro,1)/2][x]=0xFFFF0000;
//--- create the graphical resource using the resource variable
   ResourceCreate("euro_icon",euro,ArrayRange(euro,1),ArrayRange(euro,0),0,0,ArrayRang
//--- create the Euro graphical label object, to which the image from the euro_icon re
   Image("Euro","::euro_icon",10,40);
//--- another method of applying the resource, we cannot draw do it
   Image("USD","::Images\\dollar.bmp",15+ArrayRange(euro,1),40);
//--- direct method of addressing the euro.bmp resource is unavailable since it has al
   Image("E2","::Images\\euro.bmp",20+ArrayRange(euro,1)*2,40); // execution time erro
  }
Script execution result – only two OBJ_BITMAP_LABEL objects out of three ones are created. The
image of the first object has the red stripe in the middle.


--- Page 1058 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1058
An important advantage of applying the resources is that the resource files are automatically
compressed before they are included into an executable EX5 file prior to compilation. Thus, using the
resource variables allows you to put all necessary data directly into the executable EX5 file as well as
reduce the number and total size of the files compared to the conventional way of writing MQL5
programs.
Using the resource variables is particularly convenient for publishing products in the Market.
Features
· The special bitmap resource variable type informs the compiler that the resource is an image. Such
variables receive the uint type. 
· The bitmap type array resource variable may have two dimensions. In this case, the array size is
defined as [image_height ][ image_width ]. If an array of one dimension is specified, the number of
elements is equal to image_height*image_width.
· When downloading a 24-bit image, the alpha channel component is set to 255 for all the image
pixels.
· When downloading a 32-bit image without the alpha channel, the alpha channel component is also
set to 255 for all the image pixels.
· When downloading a 32-bit image with the alpha channel, the pixels are not processed in any way.
· The resource file size cannot exceed 128 Mb.
· The automatic encoding detection by BOM (header) presence is performed for string files. If BOM is
absent, the encoding is defined by the file contents. The files in the ANSI, UTF-8 and UTF-16
encodings are supported. All strings are converted to Unicode when reading data from the files.
OpenCL programs
Using the resource string variables may greatly facilitate the development of some programs. For
example, you are able to write a code of an OpenCL program in a separate CL file and then include it
as a string into your MQL5 program resources. 


--- Page 1059 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1059
#resource "seascape.cl" as string cl_program
...
int context;
if((cl_program=CLProgramCreate(context,cl_program)!=INVALID_HANDLE)
  {
   //--- perform further actions with an OpenCL program
  }
In this example, you would have had to write the entire code as a single big string if no cl_program
resource variable had been used.
See also
ResourceCreate(), ResourceSave(), PlaySound(), ObjectSetInteger(), ChartApplyTemplate(), File
Functions


--- Page 1060 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1060
Call of Imported Functions
To import functions during the execution of a mql5-program, the client terminal uses early binding.
This means that if a program has call of an imported function, the corresponding module (ex5 or dll) is
loaded during the program load. MQL5 and DLL libraries are executed in the thread of a calling
module.
It is not recommended to use the fully specified name of the module to be loaded like Drive:
\Directory\FileName.Ext. The MQL5 libraries are loaded from the terminal_dir\MQL5\Libraries folder.
If the library hasn't been found, then the client terminal performs an attempt to load it from
terminal_dir\experts folder. 
The system libraries (DLL)  are loaded by the operating system rules. If the library is already loaded
(for example, another Expert Advisor, and even from another client terminal, running in parallel), then
it uses requests to the library already loaded. Otherwise, it performs a search in the following
sequence:
1. Directory, from which the module importing dll was started. The module here is an Expert Advisor,
a script, an indicator or EX5 library;
2. Directory terminal_data_directory\MQL5\Libraries (TERMINAL_DATA_PATH\MQL5\Libraries);
3. Directory, from which the MetaTrader 5 client terminal was started;
4. System directory;
5. Windows directory;
6. Current directory;
7. Directories listed in the PATH system variable.
If the DLL library uses another DLL in its work, the first one cannot be loaded in case when there is no
second DLL.
Before an Expert Advisor (script, indicator) is loaded, a common list of all EX5 library modules is
formed. It's going to be used both from a loaded Expert Advisor (script, indicator) and from libraries
of this list. Thus the one-time loading of many times used EX5 library modules is needed. Libraries use
predefined variables of the Expert Advisor (script, indicator) they were called by.
The imported library EX5 is searched for in the following sequence:
1. Directory, path to which is set relative to the directory of the Expert Advisor (script, indicator) that
imports EX5;
2. Directory terminal_directory\MQL5\Libraries;
3. Directory MQL5\Libraries in the common directory of all MetaTrader 5 client terminals
(Common\MQL5\Libraries).
Functions imported DLL into a mql5-program must ensure the Windows API calls agreement. To ensure
such an agreement, in the source text of programs written in C or C++, use the keyword __stdcall,
which is specific to the Microsoft(r) compilers. This agreement is characterized by the following:
· caller (in our case it is a mq5-program) should "see" a prototype of a function called (imported from
the DLL), in order to properly combine parameters to a stack; 
· caller (in our case it is a mql5-program) puts parameters to the stack in a reverse order, from right
to left - in this order an imported function reads parameters passed to it; 
· parameters are passed by value, except those explicitly passed by reference (in our case strings)


--- Page 1061 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1061
· an imported function cleans the stack independently by reading parameters passed to it. 
When describing the prototype of an imported function, default parameters can be used. 
If the corresponding library is unable to load, or there is a prohibition on the DLL use, or the imported
function is not found - the Expert Advisor stops its operation with the appropriate message "Expert
Advisor stopped" in the Journal (log file). In this case the Expert Advisor will not run until it is
reinitialized. An Expert Advisor can be reinitialized as a result of recompilation or after the table of its
properties is opened and OK is pressed.
Passing Parameters
All parameters of simple types are passed by values unless it is explicitly indicated that they are
passed by reference. When a string is passed, the address of the buffer of the copied string is passed;
if a string is passed by reference, the address of the buffer of this string without copying it is passed
to the function imported from DLL.
Structures that contain dynamic arrays, strings, classes, other complex structures, as well as static or
dynamic arrays of the enumerated objects, can't be passed as a parameter to an imported function.
When passing an array to DLL, the address of the beginning of the data buffer is always passed
(irrespective of the AS_SERIES flag). A function inside a DLL knows nothing about the AS_SERIES flag,
the passed array is a static array of an undefined length; an additional parameter should be used for
specifying the array size.


--- Page 1062 ---
MQL5 programs
© 2000-2025, MetaQuotes Ltd.
1062
Runtime Errors
The executing subsystem of the client terminal has an opportunity to save the error code in case it
occurs during a MQL5 program run. There is a predefined variable _LastError for each executable
MQL5 program.
Before starting the OnInit function, the _LastError variable is reset. In case an erroneous situation
occurs during calculations or in the process of internal function calls, the _LastError variable accepts a
corresponding error code. The value stored in this variable can be obtained using the GetLastError()
function.
There are several critical errors in case of which a program is terminated immediately:
· division by zero
· going beyond array boundary
· using an incorrect object pointer
